"use strict";
exports.__esModule = true;
var point_1 = require("./point");
var Bounds = /** @class */ (function () {
    function Bounds(topLeft, bottomRight) {
        if (!topLeft) {
            return;
        }
        var points = bottomRight ? [topLeft, bottomRight] : topLeft;
        if (Array.isArray(points)) {
            for (var i = 0, len = points.length; i < len; i += 1) {
                // @ts-ignore
                this.extend(points[i]);
            }
        }
    }
    Bounds.prototype.extend = function (point) {
        var newPoint = point_1.toPoint(point);
        if (!this.min && !this.max) {
            this.min = newPoint.clone();
            this.max = newPoint.clone();
        }
        else {
            this.min.x = Math.min(newPoint.x, this.min.x);
            this.max.x = Math.max(newPoint.x, this.max.x);
            this.min.y = Math.min(newPoint.y, this.min.y);
            this.max.y = Math.max(newPoint.y, this.max.y);
        }
        return this;
    };
    Bounds.prototype.getCenter = function (round) {
        return new point_1.Point((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, round);
    };
    Bounds.prototype.getBottomLeft = function () {
        return new point_1.Point(this.min.x, this.max.y);
    };
    Bounds.prototype.getTopRight = function () {
        return new point_1.Point(this.max.x, this.min.y);
    };
    Bounds.prototype.getBottomRight = function () {
        return this.max;
    };
    Bounds.prototype.getTopLeft = function () {
        return this.min;
    };
    Bounds.prototype.getSize = function () {
        return this.max.subtract(this.min);
    };
    /**
     * 判断是否包含 输入 points 或者 bounds
     * @param obj
     */
    Bounds.prototype.contains = function (obj) {
        var min;
        var max;
        var newObj = obj;
        // @ts-ignore
        if (newObj instanceof point_1.Point || typeof newObj[0] === 'number') {
            newObj = point_1.toPoint(newObj);
        }
        else {
            newObj = toBounds(newObj);
        }
        if (newObj instanceof Bounds) {
            min = newObj.min;
            max = newObj.max;
        }
        else {
            min = max = obj;
        }
        return (min.x >= this.min.x &&
            max.x <= this.max.x &&
            min.y >= this.min.y &&
            max.y <= this.max.y);
    };
    /**
     * 判断两个bounds是否相交 ,
     * @param bounds
     */
    Bounds.prototype.intersect = function (bounds) {
        var newBounds = toBounds(bounds);
        var min = this.min;
        var max = this.max;
        var min2 = newBounds.min;
        var max2 = newBounds.max;
        var xIntersects = (max2.x >= min.x) && (min2.x <= max.x);
        var yIntersects = (max2.y >= min.y) && (min2.y <= max.y);
        return xIntersects && yIntersects;
    };
    /**
     * 判断bounds是否相互覆盖
     * @param bounds
     */
    Bounds.prototype.overlaps = function (bounds) {
        var newBounds = toBounds(bounds);
        var min = this.min;
        var max = this.max;
        var min2 = newBounds.min;
        var max2 = newBounds.max;
        var xOverlaps = (max2.x > min.x) && (min2.x < max.x);
        var yOverlaps = (max2.y > min.y) && (min2.y < max.y);
        return xOverlaps && yOverlaps;
    };
    Bounds.prototype.isValid = function () {
        return !!(this.min && this.max);
    };
    return Bounds;
}());
exports.Bounds = Bounds;
function toBounds(topLeft, bottomRight) {
    if (!topLeft || topLeft instanceof Bounds) {
        return topLeft;
    }
    return new Bounds(topLeft, bottomRight);
}
exports.toBounds = toBounds;
//# sourceMappingURL=bounds.js.map