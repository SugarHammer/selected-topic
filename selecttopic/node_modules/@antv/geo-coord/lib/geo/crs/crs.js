"use strict";
exports.__esModule = true;
var bounds_1 = require("../geometry/bounds");
var lng_lat_1 = require("../geometry/lng-lat");
var util_1 = require("../../util");
var spherical_mercator_1 = require("../projection/spherical-mercator");
var transformation_1 = require("../transformation");
var lng_lat_bounds_1 = require("../geometry/lng-lat-bounds");
var scale = 0.5 / (Math.PI * spherical_mercator_1.sphericalMercator.R);
var transform = new transformation_1.Transformation(scale, 0.5, -scale, 0.5);
exports.CRS = {
    wrapLng: [-180, 180],
    wrapLat: null,
    projection: spherical_mercator_1.sphericalMercator,
    transformation: transform,
    lngLatToPoint: function (lnglat, zoom) {
        var projectedPoint = this.projection.project(lnglat);
        var scale = this.scale(zoom);
        return this.transformation.transform(projectedPoint, scale);
    },
    pointToLngLat: function (point, zoom) {
        var scale = this.scale(zoom);
        var untransformedPoint = this.transformation.untransform(point, scale);
        return this.projection.unproject(untransformedPoint);
    },
    project: function (lnglat) {
        return this.projection.project(lnglat);
    },
    unproject: function (point) {
        return this.projection.unproject(point);
    },
    zoom: function (scale) {
        return Math.log(scale / 256) / Math.LN2;
    },
    scale: function (zoom) {
        return 256 * Math.pow(2, zoom);
    },
    getProjectedBounds: function (zoom) {
        if (this.infinite) {
            return new bounds_1.Bounds([[Infinity, Infinity], [Infinity, Infinity]]);
        }
        var b = this.projection.bounds;
        var s = this.scale(zoom);
        var min = this.transformation.transform(b.min, s);
        var max = this.transformation.transform(b.max, s);
        return new bounds_1.Bounds(min, max);
    },
    infinite: false,
    wrapLngLat: function (lnglat) {
        var lng = Array.isArray(this.wrapLng) ? util_1.wrapNum(lnglat.lng, this.wrapLng, true) : lnglat.lng;
        var lat = Array.isArray(this.wrapLat) ? util_1.wrapNum(lnglat.lat, this.wrapLat, true) : lnglat.lat;
        var alt = lnglat.alt;
        return new lng_lat_1.LngLat(lng, lat, alt);
    },
    wrapLngLatBounds: function (bounds) {
        var center = bounds.getCenter();
        var newCenter = this.wrapLngLat(center);
        var latShift = center.lat - newCenter.lat;
        var lngShift = center.lng - newCenter.lng;
        if (latShift === 0 && lngShift === 0) {
            return bounds;
        }
        var sw = bounds.getSouthWest();
        var ne = bounds.getNorthEast();
        var newSw = new lng_lat_1.LngLat(sw.lng - lngShift, sw.lat - latShift);
        var newNe = new lng_lat_1.LngLat(ne.lng - lngShift, ne.lat - latShift);
        return new lng_lat_bounds_1.LngLatBounds(newSw, newNe);
    }
};
//# sourceMappingURL=crs.js.map