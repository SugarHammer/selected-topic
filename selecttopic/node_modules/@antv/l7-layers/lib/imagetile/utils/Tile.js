"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _geoCoord = require("@antv/geo-coord");

var _l7Core = require("@antv/l7-core");

var _ImageTile = _interopRequireDefault(require("./ImageTile"));

var _tileCache = _interopRequireDefault(require("./tileCache"));

var CacheLimit = 30;

var Tile = function () {
  function Tile(props) {
    (0, _classCallCheck2.default)(this, Tile);
    (0, _defineProperty2.default)(this, "tileList", {});
    (0, _defineProperty2.default)(this, "tileCache", void 0);
    (0, _defineProperty2.default)(this, "updateTileList", void 0);
    (0, _defineProperty2.default)(this, "tileZoom", void 0);
    (0, _defineProperty2.default)(this, "noPruneRange", void 0);
    (0, _defineProperty2.default)(this, "url", void 0);
    (0, _defineProperty2.default)(this, "resolution", void 0);
    (0, _defineProperty2.default)(this, "maxSourceZoom", void 0);
    (0, _defineProperty2.default)(this, "crstype", void 0);
    (0, _defineProperty2.default)(this, "currentCrs", void 0);
    (0, _defineProperty2.default)(this, "layerService", void 0);
    (0, _defineProperty2.default)(this, "layer", void 0);
    this.layerService = props.layerService;
    this.layer = props.layer;
    this.url = props.url;
    this.resolution = props.resolution === 'low' ? -1 : 0;
    this.maxSourceZoom = props.maxSourceZoom;
    this.crstype = props.crstype;
    this.currentCrs = new _geoCoord.GeoCoordinates.default({
      start: {
        x: 0,
        y: 0
      },
      end: {
        x: 0,
        y: 0
      },
      projection: this.crstype
    }).crs;
    this.destroyTile = this.destroyTile.bind(this);
    this.tileCache = new _tileCache.default(CacheLimit, this.destroyTile);
    this.updateTileList = [];
    this.removeTiles = this.removeTiles.bind(this);
  }

  (0, _createClass2.default)(Tile, [{
    key: "calCurrentTiles",
    value: function calCurrentTiles(oprions) {
      var _this = this;

      var NE = oprions.NE,
          SW = oprions.SW,
          tileCenter = oprions.tileCenter,
          currentZoom = oprions.currentZoom,
          minSourceZoom = oprions.minSourceZoom,
          minZoom = oprions.minZoom,
          maxZoom = oprions.maxZoom;

      if (currentZoom >= this.maxSourceZoom) {
        return;
      }

      var zoom = Math.floor(currentZoom) + this.resolution;
      this.tileZoom = zoom > this.maxSourceZoom ? this.maxSourceZoom : zoom;

      if (currentZoom < minZoom || currentZoom >= maxZoom || currentZoom < minSourceZoom) {
        this.removeTiles();
        return;
      }

      this.updateTileList = [];
      var centerPoint = this.currentCrs.lngLatToPoint((0, _geoCoord.toLngLat)(tileCenter.lng, tileCenter.lat), this.tileZoom);
      var centerXY = centerPoint.divideBy(256).floor();
      var pixelBounds = this.getPixelBounds(NE, SW, tileCenter, this.tileZoom, this.currentCrs);
      var tileRange = this.pxBoundsToTileRange(pixelBounds);
      var margin = 4;
      this.noPruneRange = new _geoCoord.Bounds(tileRange.getBottomLeft().subtract([margin, -margin]), tileRange.getTopRight().add([margin, -margin]));

      if (!(isFinite(tileRange.min.x) && isFinite(tileRange.min.y) && isFinite(tileRange.max.x) && isFinite(tileRange.max.y))) {
        throw new Error('Attempted to load an infinite number of tiles');
      }

      for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
        for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
          var coords = [i, j, this.tileZoom];
          var tile = this.tileList[coords.join('_')];

          if (tile) {
            tile.current = true;
          } else {
            this.tileList[coords.join('_')] = {
              current: true,
              coords: coords
            };
            this.updateTileList.push(coords);
          }
        }
      }

      this.updateTileList.sort(function (a, b) {
        var tile1 = a;
        var tile2 = b;
        var d1 = Math.pow(tile1[0] * 1 - centerXY.x, 2) + Math.pow(tile1[1] * 1 - centerXY.y, 2);
        var d2 = Math.pow(tile2[0] * 1 - centerXY.x, 2) + Math.pow(tile2[1] * 1 - centerXY.y, 2);
        return d1 - d2;
      });
      this.pruneTiles();
      this.updateTileList.forEach(function (coords) {
        var key = coords.join('_');

        if (_this.tileList[key].current) {
          _this.requestTile(key);
        }
      });
    }
  }, {
    key: "pxBoundsToTileRange",
    value: function pxBoundsToTileRange(pixelBounds) {
      return new _geoCoord.Bounds(pixelBounds.min.divideBy(256).floor(), pixelBounds.max.divideBy(256).ceil().subtract([1, 1]));
    }
  }, {
    key: "getPixelBounds",
    value: function getPixelBounds(NE, SW, tileCenter, tileZoom, crs) {
      var zoom = tileZoom;
      var NEPoint = crs.lngLatToPoint((0, _geoCoord.toLngLat)(NE.lng, NE.lat), zoom);
      var SWPoint = crs.lngLatToPoint((0, _geoCoord.toLngLat)(SW.lng, SW.lat), zoom);
      var centerPoint = crs.lngLatToPoint((0, _geoCoord.toLngLat)(tileCenter.lng, tileCenter.lat), zoom);
      var topHeight = centerPoint.y - NEPoint.y;
      var bottomHeight = SWPoint.y - centerPoint.y;
      var leftWidth;
      var rightWidth;

      if (tileCenter.lng - NE.lng > 0 || tileCenter.lng - SW.lng < 0) {
        var width = Math.pow(2, zoom) * 256 / 360 * (180 - NE.lng) + Math.pow(2, zoom) * 256 / 360 * (SW.lng + 180);

        if (tileCenter.lng - NE.lng > 0) {
          leftWidth = Math.pow(2, zoom) * 256 / 360 * (tileCenter.lng - NE.lng);
          rightWidth = width - leftWidth;
        } else {
          rightWidth = Math.pow(2, zoom) * 256 / 360 * (SW.lng - tileCenter.lng);
          leftWidth = width - rightWidth;
        }
      } else {
        leftWidth = Math.pow(2, zoom) * 256 / 360 * (tileCenter.lng - SW.lng);
        rightWidth = Math.pow(2, zoom) * 256 / 360 * (NE.lng - tileCenter.lng);
      }

      var pixelBounds = new _geoCoord.Bounds(centerPoint.subtract(leftWidth, topHeight), centerPoint.add(rightWidth, bottomHeight));
      return pixelBounds;
    }
  }, {
    key: "pruneTiles",
    value: function pruneTiles() {
      var _this2 = this;

      Object.keys(this.tileList).map(function (key) {
        var c = _this2.tileList[key].coords;

        if (c[2] !== _this2.tileZoom || !_this2.noPruneRange.contains(new _geoCoord.Point(c[0], c[1]))) {
          _this2.tileList[key].current = false;
        }
      });
      Object.keys(this.tileList).map(function (key) {
        var tile = _this2.tileList[key];
        tile.retain = tile.current;
      });
      Object.keys(this.tileList).map(function (key) {
        var tile = _this2.tileList[key];

        if (tile.current && !tile.active) {
          var _key$split$map = key.split('_').map(function (v) {
            return Number(v);
          }),
              _key$split$map2 = (0, _slicedToArray2.default)(_key$split$map, 3),
              x = _key$split$map2[0],
              y = _key$split$map2[1],
              z = _key$split$map2[2];

          if (!_this2.retainParent(x, y, z, z - 5)) {
            _this2.retainChildren(x, y, z, z + 2);
          }
        }
      });
      this.removeOutTiles();
    }
  }, {
    key: "requestTile",
    value: function requestTile(key) {
      var t = this.tileList[key];

      if (!t) {
        return;
      }

      var tile = this.tileCache.getTile(key);

      if (!tile) {
        var container = (0, _l7Core.createLayerContainer)(this.layer.sceneContainer);
        tile = new _ImageTile.default(key, this.url, container, this.layer.sceneContainer);
        tile.name = key;
        t.current = true;
        t.retain = true;
        t.active = true;
        this.layer.layerChildren.push(tile.imageLayer);
        this.tileCache.setTile(tile, key);
        this.pruneTiles();
        this.layerService.updateLayerRenderList();
        this.layerService.renderLayers();
      } else {
        tile.imageLayer.show();
        t.current = true;
        t.retain = true;
        t.active = true;
        this.pruneTiles();
      }
    }
  }, {
    key: "retainParent",
    value: function retainParent(x, y, z, minZoom) {
      var x2 = Math.floor(x / 2);
      var y2 = Math.floor(y / 2);
      var z2 = z - 1;
      var tile = this.tileList[[x2, y2, z2].join('_')];

      if (tile && tile.active) {
        tile.retain = true;
        return true;
      } else if (tile && tile.loaded) {
        tile.retain = true;
      }

      if (z2 > minZoom) {
        return this.retainParent(x2, y2, z2, minZoom);
      }

      return false;
    }
  }, {
    key: "retainChildren",
    value: function retainChildren(x, y, z, maxZoom) {
      for (var i = 2 * x; i < 2 * x + 2; i++) {
        for (var j = 2 * y; j < 2 * y + 2; j++) {
          var key = [i, j, z + 1].join('_');
          var tile = this.tileList[key];

          if (tile && tile.active) {
            tile.retain = true;
            continue;
          } else if (tile && tile.loaded) {
            tile.retain = true;
          }

          if (z + 1 < maxZoom) {
            this.retainChildren(i, j, z + 1, maxZoom);
          }
        }
      }
    }
  }, {
    key: "destroyTile",
    value: function destroyTile(tile) {
      var layerIndex = this.layer.layerChildren.indexOf(tile.imageLayer);

      if (layerIndex > -1) {
        this.layer.layerChildren.splice(layerIndex, 1);
      }

      tile.imageLayer.destroy();
      this.layerService.updateLayerRenderList();
      this.layerService.renderLayers();
      tile = null;
    }
  }, {
    key: "removeOutTiles",
    value: function removeOutTiles() {
      for (var key in this.tileList) {
        if (!this.tileList[key].retain) {
          var tile = this.tileCache.getTile(key);

          if (tile) {
            tile.imageLayer.hide();
          }

          delete this.tileList[key];
        }
      }
    }
  }, {
    key: "removeTiles",
    value: function removeTiles() {
      this.layer.layerChildren.forEach(function (layer) {
        layer.destroy();
      });
      this.layer.layerChildren = [];
      this.layerService.updateLayerRenderList();
      this.layerService.renderLayers();
      this.tileList = {};
      this.tileCache.destory();
    }
  }]);
  return Tile;
}();

exports.default = Tile;
//# sourceMappingURL=Tile.js.map