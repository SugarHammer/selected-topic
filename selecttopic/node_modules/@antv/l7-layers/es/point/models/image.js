import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _assertThisInitialized from "@babel/runtime/helpers/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _isNumber from "lodash/isNumber";

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

import { AttributeType, gl } from '@antv/l7-core';
import { getMask } from '@antv/l7-utils';
import BaseModel from '../../core/BaseModel';
import { PointImageTriangulation } from '../../core/triangulation';
var pointImageFrag = "\nuniform sampler2D u_texture;\nvarying vec4 v_color;\nvarying vec2 v_uv;\nuniform vec2 u_textSize;\nuniform float u_opacity : 1;\n\nvarying mat4 styleMappingMat; // \u4F20\u9012\u4ECE\u7247\u5143\u4E2D\u4F20\u9012\u7684\u6620\u5C04\u6570\u636E\n\n#pragma include \"picking\"\n\nvoid main(){\n      float opacity = styleMappingMat[0][0];\n      float size = styleMappingMat[1][0];\n      vec2 pos = v_uv / u_textSize + gl_PointCoord / u_textSize * 64.;\n      vec4 textureColor;\n\n      // Y = 0.299R + 0.587G + 0.114B // \u4EAE\u5EA6\u63D0\u53D6\n     \n      textureColor = texture2D(u_texture, pos);\n\n      // Tip: \u53BB\u9664\u8FB9\u7F18\u90E8\u5206 mipmap \u5BFC\u81F4\u7684\u6DF7\u5408\u53D8\u6697\n      float fragmengTocenter = distance(vec2(0.5), gl_PointCoord);\n      if(fragmengTocenter >= 0.5) {\n            float luma = 0.299 * textureColor.r + 0.587 * textureColor.g + 0.114 * textureColor.b;\n            textureColor.a *= luma;\n      }\n      \n      \n\n      if(all(lessThan(v_color, vec4(1.0+0.00001))) && all(greaterThan(v_color, vec4(1.0-0.00001))) || v_color==vec4(1.0)){\n            gl_FragColor= textureColor;\n      }else {\n            gl_FragColor= step(0.01, textureColor.z) * v_color;\n      }\n\n      gl_FragColor.a = gl_FragColor.a * opacity;\n      gl_FragColor = filterColor(gl_FragColor);\n}\n";
var pointImageVert = "precision highp float;\nattribute vec3 a_Position;\nattribute vec4 a_Color;\nattribute vec2 a_Uv;\nattribute float a_Size;\nvarying vec4 v_color;\nvarying vec2 v_uv;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nuniform float u_stroke_width : 1;\nuniform vec2 u_offsets;\n\nuniform float u_opacity : 1;\n\nvarying mat4 styleMappingMat; // \u7528\u4E8E\u5C06\u5728\u9876\u70B9\u7740\u8272\u5668\u4E2D\u8BA1\u7B97\u597D\u7684\u6837\u5F0F\u503C\u4F20\u9012\u7ED9\u7247\u5143\n\n#pragma include \"styleMapping\"\n#pragma include \"styleMappingCalOpacity\"\n\n#pragma include \"projection\"\n#pragma include \"picking\"\n\nvoid main() {\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n  styleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - empty\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0\n  );\n\n  float rowCount = u_cellTypeLayout[0][0];    // \u5F53\u524D\u7684\u6570\u636E\u7EB9\u7406\u6709\u51E0\u884C\n  float columnCount = u_cellTypeLayout[0][1]; // \u5F53\u770B\u5230\u6570\u636E\u7EB9\u7406\u6709\u51E0\u5217\n  float columnWidth = 1.0/columnCount;  // \u5217\u5BBD\n  float rowHeight = 1.0/rowCount;       // \u884C\u9AD8\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // \u7B2Cn\u4E2A\u9876\u70B9\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u884C\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u5217\n  \n  // cell \u56FA\u5B9A\u987A\u5E8F opacity -> strokeOpacity -> strokeWidth -> stroke ... \n  // \u6309\u987A\u5E8F\u4ECE cell \u4E2D\u53D6\u503C\u3001\u82E5\u6CA1\u6709\u5219\u81EA\u52A8\u5F80\u4E0B\u53D6\u503C\n  float textureOffset = 0.0; // \u5728 cell \u4E2D\u53D6\u503C\u7684\u504F\u79FB\u91CF\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n\n  styleMappingMat[1][0] = a_Size;\n\n  vec2 textrueOffsets = vec2(0.0, 0.0);\n  if(hasOffsets()) {\n    vec2 valueXPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    textrueOffsets.r = pos2value(valueXPos, columnWidth, rowHeight); // x\n    textureOffset += 1.0;\n\n    vec2 valueYPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    textrueOffsets.g = pos2value(valueYPos, columnWidth, rowHeight); // x\n    textureOffset += 1.0;\n  } else {\n    textrueOffsets = u_offsets;\n  }\n\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n   v_color = a_Color;\n   v_uv = a_Uv;\n   vec4 project_pos = project_position(vec4(a_Position, 1.0));\n   \n  //  vec2 offset = project_pixel(u_offsets);\n  vec2 offset = project_pixel(textrueOffsets);\n\n  //  gl_Position = project_common_position_to_clipspace(vec4(vec2(project_pos.xy + offset),project_pos.z, 1.0));\n\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n      gl_Position = u_Mvp * vec4(vec2(project_pos.xy + offset),project_pos.z, 1.0);\n    } else {\n      gl_Position = project_common_position_to_clipspace(vec4(vec2(project_pos.xy + offset),project_pos.z, 1.0));\n    }\n   gl_PointSize = a_Size * 2.0 * u_DevicePixelRatio;\n\n  setPickingColor(a_PickingColor);\n\n}\n";

var ImageModel = function (_BaseModel) {
  _inherits(ImageModel, _BaseModel);

  var _super = _createSuper(ImageModel);

  function ImageModel() {
    var _this;

    _classCallCheck(this, ImageModel);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "texture", void 0);

    _defineProperty(_assertThisInitialized(_this), "updateTexture", function () {
      var createTexture2D = _this.rendererService.createTexture2D;

      if (_this.texture) {
        _this.texture.update({
          data: _this.iconService.getCanvas(),
          mag: 'linear',
          min: 'linear mipmap nearest',
          mipmap: true
        });

        _this.layer.renderLayers();

        return;
      }

      _this.texture = createTexture2D({
        data: _this.iconService.getCanvas(),
        mag: gl.LINEAR,
        min: gl.LINEAR_MIPMAP_LINEAR,
        premultiplyAlpha: false,
        width: 1024,
        height: _this.iconService.canvasHeight || 128,
        mipmap: true
      });
    });

    return _this;
  }

  _createClass(ImageModel, [{
    key: "getUninforms",
    value: function getUninforms() {
      var _ref = this.layer.getLayerConfig(),
          opacity = _ref.opacity,
          _ref$offsets = _ref.offsets,
          offsets = _ref$offsets === void 0 ? [0, 0] : _ref$offsets;

      if (this.rendererService.getDirty()) {
        this.texture.bind();
      }

      if (this.dataTextureTest && this.dataTextureNeedUpdate({
        opacity: opacity,
        offsets: offsets
      })) {
        this.judgeStyleAttributes({
          opacity: opacity,
          offsets: offsets
        });
        var encodeData = this.layer.getEncodedData();

        var _this$calDataFrame = this.calDataFrame(this.cellLength, encodeData, this.cellProperties),
            data = _this$calDataFrame.data,
            width = _this$calDataFrame.width,
            height = _this$calDataFrame.height;

        this.rowCount = height;
        this.dataTexture = this.cellLength > 0 && data.length > 0 ? this.createTexture2D({
          flipY: true,
          data: data,
          format: gl.LUMINANCE,
          type: gl.FLOAT,
          width: width,
          height: height
        }) : this.createTexture2D({
          flipY: true,
          data: [1],
          format: gl.LUMINANCE,
          type: gl.FLOAT,
          width: 1,
          height: 1
        });
      }

      return {
        u_dataTexture: this.dataTexture,
        u_cellTypeLayout: this.getCellTypeLayout(),
        u_texture: this.texture,
        u_textSize: [1024, this.iconService.canvasHeight || 128],
        u_opacity: _isNumber(opacity) ? opacity : 1.0,
        u_offsets: this.isOffsetStatic(offsets) ? offsets : [0, 0]
      };
    }
  }, {
    key: "initModels",
    value: function initModels() {
      this.registerBuiltinAttributes();
      this.updateTexture();
      this.iconService.on('imageUpdate', this.updateTexture);
      return this.buildModels();
    }
  }, {
    key: "clearModels",
    value: function clearModels() {
      var _this$texture, _this$dataTexture;

      (_this$texture = this.texture) === null || _this$texture === void 0 ? void 0 : _this$texture.destroy();
      (_this$dataTexture = this.dataTexture) === null || _this$dataTexture === void 0 ? void 0 : _this$dataTexture.destroy();
      this.iconService.off('imageUpdate', this.updateTexture);
    }
  }, {
    key: "buildModels",
    value: function buildModels() {
      var _ref2 = this.layer.getLayerConfig(),
          _ref2$mask = _ref2.mask,
          mask = _ref2$mask === void 0 ? false : _ref2$mask,
          _ref2$maskInside = _ref2.maskInside,
          maskInside = _ref2$maskInside === void 0 ? true : _ref2$maskInside;

      return [this.layer.buildLayerModel({
        moduleName: 'pointImage',
        vertexShader: pointImageVert,
        fragmentShader: pointImageFrag,
        triangulation: PointImageTriangulation,
        primitive: gl.POINTS,
        depth: {
          enable: false
        },
        blend: this.getBlend(),
        stencil: getMask(mask, maskInside)
      })];
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      var _this2 = this;

      this.styleAttributeService.registerStyleAttribute({
        name: 'size',
        type: AttributeType.Attribute,
        descriptor: {
          name: 'a_Size',
          buffer: {
            usage: gl.DYNAMIC_DRAW,
            data: [],
            type: gl.FLOAT
          },
          size: 1,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var _feature$size = feature.size,
                size = _feature$size === void 0 ? 5 : _feature$size;
            return Array.isArray(size) ? [size[0]] : [size];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'uv',
        type: AttributeType.Attribute,
        descriptor: {
          name: 'a_Uv',
          buffer: {
            usage: gl.DYNAMIC_DRAW,
            data: [],
            type: gl.FLOAT
          },
          size: 2,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var iconMap = _this2.iconService.getIconMap();

            var shape = feature.shape;

            var _ref3 = iconMap[shape] || {
              x: 0,
              y: 0
            },
                x = _ref3.x,
                y = _ref3.y;

            return [x, y];
          }
        }
      });
    }
  }]);

  return ImageModel;
}(BaseModel);

export { ImageModel as default };
//# sourceMappingURL=image.js.map