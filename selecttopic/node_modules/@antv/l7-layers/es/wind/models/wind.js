import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _assertThisInitialized from "@babel/runtime/helpers/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _defineProperty from "@babel/runtime/helpers/defineProperty";

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

import { AttributeType, gl } from '@antv/l7-core';
import { FrequencyController } from '@antv/l7-utils';
import BaseModel from '../../core/BaseModel';
import { RasterImageTriangulation } from '../../core/triangulation';
var WindFrag = "precision mediump float;\nuniform float u_opacity: 1.0;\nuniform sampler2D u_texture;\nvarying vec2 v_texCoord;\nvoid main() {\n  vec4 color = texture2D(u_texture,vec2(v_texCoord.x,v_texCoord.y));\n  gl_FragColor = color;\n  gl_FragColor.a *= u_opacity;\n}\n";
var WindVert = "precision highp float;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nattribute vec3 a_Position;\nattribute vec2 a_Uv;\nvarying vec2 v_texCoord;\n#pragma include \"projection\"\nvoid main() {\n   v_texCoord = a_Uv;\n   vec4 project_pos = project_position(vec4(a_Position, 1.0));\n   // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy,0., 1.0));\n   if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n      gl_Position = u_Mvp * (vec4(project_pos.xy,0., 1.0));\n   } else {\n      gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy,0., 1.0));\n   }\n}\n";
import { Wind } from './windRender';
var defaultRampColors = {
  0.0: '#3288bd',
  0.1: '#66c2a5',
  0.2: '#abdda4',
  0.3: '#e6f598',
  0.4: '#fee08b',
  0.5: '#fdae61',
  0.6: '#f46d43',
  1.0: '#d53e4f'
};

var WindModel = function (_BaseModel) {
  _inherits(WindModel, _BaseModel);

  var _super = _createSuper(WindModel);

  function WindModel() {
    var _this;

    _classCallCheck(this, WindModel);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "texture", void 0);

    _defineProperty(_assertThisInitialized(_this), "colorModel", void 0);

    _defineProperty(_assertThisInitialized(_this), "wind", void 0);

    _defineProperty(_assertThisInitialized(_this), "imageCoords", void 0);

    _defineProperty(_assertThisInitialized(_this), "sizeScale", 0.5);

    _defineProperty(_assertThisInitialized(_this), "frequency", new FrequencyController(7.2));

    return _this;
  }

  _createClass(WindModel, [{
    key: "render",
    value: function render() {
      var _this2 = this;

      this.frequency.run(function () {
        _this2.drawWind();
      });
      this.drawColorMode();
    }
  }, {
    key: "getUninforms",
    value: function getUninforms() {
      throw new Error('Method not implemented.');
    }
  }, {
    key: "initModels",
    value: function initModels() {
      var _this3 = this;

      var createTexture2D = this.rendererService.createTexture2D;
      var source = this.layer.getSource();
      this.texture = createTexture2D({
        height: 0,
        width: 0
      });
      var glContext = this.rendererService.getGLContext();
      this.imageCoords = source.data.dataArray[0].coordinates;
      source.data.images.then(function (imageData) {
        var _ref = _this3.layer.getLayerConfig(),
            _ref$uMin = _ref.uMin,
            uMin = _ref$uMin === void 0 ? -21.32 : _ref$uMin,
            _ref$uMax = _ref.uMax,
            uMax = _ref$uMax === void 0 ? 26.8 : _ref$uMax,
            _ref$vMin = _ref.vMin,
            vMin = _ref$vMin === void 0 ? -21.57 : _ref$vMin,
            _ref$vMax = _ref.vMax,
            vMax = _ref$vMax === void 0 ? 21.42 : _ref$vMax,
            _ref$fadeOpacity = _ref.fadeOpacity,
            fadeOpacity = _ref$fadeOpacity === void 0 ? 0.996 : _ref$fadeOpacity,
            _ref$speedFactor = _ref.speedFactor,
            speedFactor = _ref$speedFactor === void 0 ? 0.25 : _ref$speedFactor,
            _ref$dropRate = _ref.dropRate,
            dropRate = _ref$dropRate === void 0 ? 0.003 : _ref$dropRate,
            _ref$dropRateBump = _ref.dropRateBump,
            dropRateBump = _ref$dropRateBump === void 0 ? 0.01 : _ref$dropRateBump,
            _ref$rampColors = _ref.rampColors,
            rampColors = _ref$rampColors === void 0 ? defaultRampColors : _ref$rampColors,
            _ref$sizeScale = _ref.sizeScale,
            sizeScale = _ref$sizeScale === void 0 ? 0.5 : _ref$sizeScale;

        _this3.sizeScale = sizeScale;

        var _this3$getWindSize = _this3.getWindSize(),
            imageWidth = _this3$getWindSize.imageWidth,
            imageHeight = _this3$getWindSize.imageHeight;

        var options = {
          glContext: glContext,
          imageWidth: imageWidth,
          imageHeight: imageHeight,
          fadeOpacity: fadeOpacity,
          speedFactor: speedFactor,
          dropRate: dropRate,
          dropRateBump: dropRateBump,
          rampColors: rampColors
        };
        _this3.wind = new Wind(options);

        _this3.wind.setWind({
          uMin: uMin,
          uMax: uMax,
          vMin: vMin,
          vMax: vMax,
          image: imageData[0]
        });

        _this3.texture = createTexture2D({
          data: imageData[0],
          width: imageData[0].width,
          height: imageData[0].height
        });

        _this3.layerService.updateLayerRenderList();

        _this3.layerService.renderLayers();
      });
      this.colorModel = this.layer.buildLayerModel({
        moduleName: 'WindLayer',
        vertexShader: WindVert,
        fragmentShader: WindFrag,
        triangulation: RasterImageTriangulation,
        primitive: gl.TRIANGLES,
        depth: {
          enable: false
        },
        blend: this.getBlend()
      });
      return [this.colorModel];
    }
  }, {
    key: "getWindSize",
    value: function getWindSize() {
      var p1 = this.mapService.lngLatToPixel(this.imageCoords[0]);
      var p2 = this.mapService.lngLatToPixel(this.imageCoords[1]);
      var imageWidth = Math.floor((p2.x - p1.x) * this.sizeScale);
      var imageHeight = Math.floor((p1.y - p2.y) * this.sizeScale);
      return {
        imageWidth: imageWidth,
        imageHeight: imageHeight
      };
    }
  }, {
    key: "buildModels",
    value: function buildModels() {
      return this.initModels();
    }
  }, {
    key: "clearModels",
    value: function clearModels() {
      var _this$texture, _this$wind;

      (_this$texture = this.texture) === null || _this$texture === void 0 ? void 0 : _this$texture.destroy();
      (_this$wind = this.wind) === null || _this$wind === void 0 ? void 0 : _this$wind.destroy();
    }
  }, {
    key: "getConfigSchema",
    value: function getConfigSchema() {
      return {
        properties: {
          opacity: {
            type: 'number',
            minimum: 0,
            maximum: 1
          }
        }
      };
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      this.styleAttributeService.registerStyleAttribute({
        name: 'uv',
        type: AttributeType.Attribute,
        descriptor: {
          name: 'a_Uv',
          buffer: {
            usage: gl.DYNAMIC_DRAW,
            data: [],
            type: gl.FLOAT
          },
          size: 2,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            return [vertex[3], vertex[4]];
          }
        }
      });
    }
  }, {
    key: "drawWind",
    value: function drawWind() {
      if (this.wind) {
        var _ref2 = this.layer.getLayerConfig(),
            _ref2$uMin = _ref2.uMin,
            uMin = _ref2$uMin === void 0 ? -21.32 : _ref2$uMin,
            _ref2$uMax = _ref2.uMax,
            uMax = _ref2$uMax === void 0 ? 26.8 : _ref2$uMax,
            _ref2$vMin = _ref2.vMin,
            vMin = _ref2$vMin === void 0 ? -21.57 : _ref2$vMin,
            _ref2$vMax = _ref2.vMax,
            vMax = _ref2$vMax === void 0 ? 21.42 : _ref2$vMax,
            _ref2$numParticles = _ref2.numParticles,
            numParticles = _ref2$numParticles === void 0 ? 65535 : _ref2$numParticles,
            _ref2$fadeOpacity = _ref2.fadeOpacity,
            fadeOpacity = _ref2$fadeOpacity === void 0 ? 0.996 : _ref2$fadeOpacity,
            _ref2$speedFactor = _ref2.speedFactor,
            speedFactor = _ref2$speedFactor === void 0 ? 0.25 : _ref2$speedFactor,
            _ref2$dropRate = _ref2.dropRate,
            dropRate = _ref2$dropRate === void 0 ? 0.003 : _ref2$dropRate,
            _ref2$dropRateBump = _ref2.dropRateBump,
            dropRateBump = _ref2$dropRateBump === void 0 ? 0.01 : _ref2$dropRateBump,
            _ref2$rampColors = _ref2.rampColors,
            rampColors = _ref2$rampColors === void 0 ? defaultRampColors : _ref2$rampColors,
            _ref2$sizeScale = _ref2.sizeScale,
            sizeScale = _ref2$sizeScale === void 0 ? 0.5 : _ref2$sizeScale;

        if (typeof sizeScale === 'number' && sizeScale !== this.sizeScale) {
          this.sizeScale = sizeScale;

          var _this$getWindSize = this.getWindSize(),
              imageWidth = _this$getWindSize.imageWidth,
              imageHeight = _this$getWindSize.imageHeight;

          this.wind.reSize(imageWidth, imageHeight);
        }

        this.wind.updateWindDir(uMin, uMax, vMin, vMax);
        this.wind.updateParticelNum(numParticles);
        this.wind.updateColorRampTexture(rampColors);
        this.wind.fadeOpacity = fadeOpacity;
        this.wind.speedFactor = speedFactor;
        this.wind.dropRate = dropRate;
        this.wind.dropRateBump = dropRateBump;

        var _this$wind$draw = this.wind.draw(),
            d = _this$wind$draw.d,
            w = _this$wind$draw.w,
            h = _this$wind$draw.h;

        this.rendererService.setBaseState();
        this.texture.update({
          data: d,
          width: w,
          height: h
        });
      }
    }
  }, {
    key: "drawColorMode",
    value: function drawColorMode() {
      var _ref3 = this.layer.getLayerConfig(),
          opacity = _ref3.opacity;

      this.colorModel.draw({
        uniforms: {
          u_opacity: opacity || 1.0,
          u_texture: this.texture
        }
      });
    }
  }]);

  return WindModel;
}(BaseModel);

export { WindModel as default };
//# sourceMappingURL=wind.js.map