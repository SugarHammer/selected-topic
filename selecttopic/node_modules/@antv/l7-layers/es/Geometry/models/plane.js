import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _assertThisInitialized from "@babel/runtime/helpers/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _defineProperty from "@babel/runtime/helpers/defineProperty";

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

import { AttributeType, gl } from '@antv/l7-core';
import { Version } from '@antv/l7-maps';
import { getMask } from '@antv/l7-utils';
import BaseModel from '../../core/BaseModel';
var planeFrag = "\nuniform sampler2D u_texture;\nuniform float u_mapFlag;\nuniform float u_opacity;\n\nvarying vec3 v_Color;\nvarying vec2 v_uv;\nvarying float v_clip;\n\n#pragma include \"picking\"\nvoid main() {\n  // gl_FragColor = vec4(v_Color, u_opacity);\n  if(u_mapFlag > 0.0) {\n    gl_FragColor = texture2D(u_texture, vec2(v_uv.x, 1.0 - v_uv.y));\n    gl_FragColor.a *= u_opacity;\n  } else {\n    // gl_FragColor = vec4(v_uv, 0.0, u_opacity);\n    gl_FragColor = vec4(v_Color, u_opacity);\n  }\n  gl_FragColor.a *= v_clip;\n  gl_FragColor = filterColor(gl_FragColor);\n}\n";
var planeVert = "precision highp float;\nuniform mat4 u_ModelMatrix;\n\nuniform mat4 u_Mvp;\nuniform float u_opacity;\nuniform float u_terrainClipHeight;\n\nattribute vec3 a_Position;\nattribute vec2 a_Uv;\nattribute vec3 a_Color;\n\nvarying vec3 v_Color;\nvarying vec2 v_uv;\nvarying float v_clip;\n\n#pragma include \"projection\"\n#pragma include \"picking\"\nvoid main() {\n   v_Color = a_Color;\n   v_uv = a_Uv;\n  \n   vec4 project_pos = project_position(vec4(a_Position, 1.0));\n\n   v_clip = 1.0;\n   if(a_Position.z < u_terrainClipHeight) {\n      v_clip = 0.0;\n   }\n  \n   // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy,0., 1.0));\n\n   // float x = 1.0;\n   // float y = 0.0;\n   // float z = 0.0;\n   // mat3 translateMatrix = mat3(\n   //    1.0, 0.0, 0.0 \n   //    0.0, 1.0, 0.0\n   //    -project_pos.x,    -project_pos.y,  1.0\n   // );\n   //  mat4 translateMatrix = mat4(\n   //    1.0, 0.0, 0.0, 0.0 ,\n   //    0.0, 1.0, 0.0, 0.0,\n   //    0.0, 0.0, 1.0, 0.0,\n   //    1.0, 0.0, 0.0, 1.0\n   // );\n\n   if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n      gl_Position = u_Mvp * (vec4(project_pos.xy, a_Position.z, 1.0));\n   } else {\n      gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy, a_Position.z, 1.0));\n   }\n\n   setPickingColor(a_PickingColor);\n}\n";

var PlaneModel = function (_BaseModel) {
  _inherits(PlaneModel, _BaseModel);

  var _super = _createSuper(PlaneModel);

  function PlaneModel() {
    var _this;

    _classCallCheck(this, PlaneModel);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "texture", void 0);

    _defineProperty(_assertThisInitialized(_this), "mapTexture", void 0);

    _defineProperty(_assertThisInitialized(_this), "positions", void 0);

    _defineProperty(_assertThisInitialized(_this), "indices", void 0);

    _defineProperty(_assertThisInitialized(_this), "planeGeometryTriangulation", function () {
      var _this2;

      var _ref = _this.layer.getLayerConfig(),
          _ref$width = _ref.width,
          width = _ref$width === void 0 ? 1 : _ref$width,
          _ref$height = _ref.height,
          height = _ref$height === void 0 ? 1 : _ref$height,
          _ref$widthSegments = _ref.widthSegments,
          widthSegments = _ref$widthSegments === void 0 ? 1 : _ref$widthSegments,
          _ref$heightSegments = _ref.heightSegments,
          heightSegments = _ref$heightSegments === void 0 ? 1 : _ref$heightSegments,
          _ref$center = _ref.center,
          center = _ref$center === void 0 ? [120, 30] : _ref$center,
          terrainTexture = _ref.terrainTexture;

      var _this$initPlane = (_this2 = _this).initPlane.apply(_this2, [width, height, widthSegments, heightSegments].concat(_toConsumableArray(center))),
          indices = _this$initPlane.indices,
          positions = _this$initPlane.positions;

      _this.positions = positions;
      _this.indices = indices;

      if (terrainTexture) {
        _this.loadTerrainTexture();
      }

      return {
        vertices: positions,
        indices: indices,
        size: 5
      };
    });

    _defineProperty(_assertThisInitialized(_this), "planeGeometryUpdateTriangulation", function () {
      return {
        vertices: _this.positions,
        indices: _this.indices,
        size: 5
      };
    });

    return _this;
  }

  _createClass(PlaneModel, [{
    key: "initPlane",
    value: function initPlane() {
      var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var widthSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      var heightSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      var lng = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 120;
      var lat = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 30;
      var widthHalf = width / 2;
      var heightHalf = height / 2;
      var gridX = Math.floor(widthSegments);
      var gridY = Math.floor(heightSegments);
      var gridX1 = gridX + 1;
      var gridY1 = gridY + 1;
      var segmentWidth = width / gridX;
      var segmentHeight = height / gridY;
      var indices = [];
      var positions = [];

      for (var iy = 0; iy < gridY1; iy++) {
        var y = iy * segmentHeight - heightHalf;

        for (var ix = 0; ix < gridX1; ix++) {
          var x = ix * segmentWidth - widthHalf;

          if (this.mapService.version === Version['GAODE2.x']) {
            var _ref2 = this.mapService.lngLatToCoord([x + lng, -y + lat]),
                _ref3 = _slicedToArray(_ref2, 2),
                a = _ref3[0],
                b = _ref3[1];

            positions.push(a, b, 0);
          } else {
            positions.push(x + lng, -y + lat, 0);
          }

          positions.push(ix / gridX);
          positions.push(1 - iy / gridY);
        }
      }

      for (var _iy = 0; _iy < gridY; _iy++) {
        for (var _ix = 0; _ix < gridX; _ix++) {
          var _a = _ix + gridX1 * _iy;

          var _b = _ix + gridX1 * (_iy + 1);

          var c = _ix + 1 + gridX1 * (_iy + 1);
          var d = _ix + 1 + gridX1 * _iy;
          indices.push(_a, _b, d);
          indices.push(_b, c, d);
        }
      }

      return {
        indices: indices,
        positions: positions
      };
    }
  }, {
    key: "getUninforms",
    value: function getUninforms() {
      var _ref4 = this.layer.getLayerConfig(),
          opacity = _ref4.opacity,
          mapTexture = _ref4.mapTexture,
          _ref4$terrainClipHeig = _ref4.terrainClipHeight,
          terrainClipHeight = _ref4$terrainClipHeig === void 0 ? 0 : _ref4$terrainClipHeig,
          terrainTexture = _ref4.terrainTexture;

      if (this.mapTexture !== mapTexture) {
        this.mapTexture = mapTexture;
        this.texture.destroy();
        this.updateTexture(mapTexture);
      }

      return {
        u_opacity: opacity || 1,
        u_mapFlag: mapTexture ? 1 : 0,
        u_terrainClipHeight: terrainTexture ? terrainClipHeight : -1,
        u_texture: this.texture
      };
    }
  }, {
    key: "clearModels",
    value: function clearModels() {
      this.texture.destroy();
    }
  }, {
    key: "initModels",
    value: function initModels() {
      var _ref5 = this.layer.getLayerConfig(),
          _ref5$mask = _ref5.mask,
          mask = _ref5$mask === void 0 ? false : _ref5$mask,
          _ref5$maskInside = _ref5.maskInside,
          maskInside = _ref5$maskInside === void 0 ? true : _ref5$maskInside,
          mapTexture = _ref5.mapTexture;

      this.mapTexture = mapTexture;
      var createTexture2D = this.rendererService.createTexture2D;
      this.texture = createTexture2D({
        height: 0,
        width: 0
      });
      this.updateTexture(mapTexture);
      return [this.layer.buildLayerModel({
        moduleName: 'geometry_plane',
        vertexShader: planeVert,
        fragmentShader: planeFrag,
        triangulation: this.planeGeometryTriangulation,
        primitive: gl.TRIANGLES,
        depth: {
          enable: true
        },
        blend: this.getBlend(),
        stencil: getMask(mask, maskInside)
      })];
    }
  }, {
    key: "getImageData",
    value: function getImageData(img) {
      var canvas = document.createElement('canvas');
      var ctx = canvas.getContext('2d');
      var width = img.width,
          height = img.height;
      canvas.width = width;
      canvas.height = height;
      ctx.drawImage(img, 0, 0, width, height);
      var imageData = ctx.getImageData(0, 0, width, height);
      return imageData;
    }
  }, {
    key: "loadTerrainTexture",
    value: function loadTerrainTexture() {
      var _this3 = this;

      var _ref6 = this.layer.getLayerConfig(),
          _ref6$mask = _ref6.mask,
          mask = _ref6$mask === void 0 ? false : _ref6$mask,
          _ref6$maskInside = _ref6.maskInside,
          maskInside = _ref6$maskInside === void 0 ? true : _ref6$maskInside,
          _ref6$widthSegments = _ref6.widthSegments,
          widthSegments = _ref6$widthSegments === void 0 ? 1 : _ref6$widthSegments,
          _ref6$heightSegments = _ref6.heightSegments,
          heightSegments = _ref6$heightSegments === void 0 ? 1 : _ref6$heightSegments,
          terrainTexture = _ref6.terrainTexture,
          _ref6$rgb2height = _ref6.rgb2height,
          rgb2height = _ref6$rgb2height === void 0 ? function (r, g, b) {
        return r + g + b;
      } : _ref6$rgb2height;

      var terrainImage = new Image();
      terrainImage.crossOrigin = 'anonymous';

      terrainImage.onload = function () {
        var imgWidth = terrainImage.width;
        var imgHeight = terrainImage.height;

        var imageData = _this3.getImageData(terrainImage).data;

        var gridX = Math.floor(widthSegments);
        var gridY = Math.floor(heightSegments);
        var gridX1 = gridX + 1;
        var gridY1 = gridY + 1;
        var widthStep = imgWidth / gridX;
        var heihgtStep = imgHeight / gridY;

        for (var iy = 0; iy < gridY1; iy++) {
          var imgIndexY = Math.floor(iy * heihgtStep);
          var imgLen = imgIndexY * imgWidth;

          for (var ix = 0; ix < gridX1; ix++) {
            var imgIndexX = Math.floor(ix * widthStep);
            var imgDataIndex = (imgLen + imgIndexX) * 4;
            var r = imageData[imgDataIndex];
            var g = imageData[imgDataIndex + 1];
            var b = imageData[imgDataIndex + 2];
            var z = (iy * gridX1 + ix) * 5 + 2;
            _this3.positions[z] = rgb2height(r, g, b);
          }
        }

        _this3.layer.models = [_this3.layer.buildLayerModel({
          moduleName: 'geometry_plane',
          vertexShader: planeVert,
          fragmentShader: planeFrag,
          triangulation: _this3.planeGeometryUpdateTriangulation,
          primitive: gl.TRIANGLES,
          depth: {
            enable: true
          },
          blend: _this3.getBlend(),
          stencil: getMask(mask, maskInside)
        })];

        _this3.layerService.renderLayers();
      };

      terrainImage.src = terrainTexture;
    }
  }, {
    key: "buildModels",
    value: function buildModels() {
      return this.initModels();
    }
  }, {
    key: "updateTexture",
    value: function updateTexture(mapTexture) {
      var _this4 = this;

      var createTexture2D = this.rendererService.createTexture2D;

      if (mapTexture) {
        var img = new Image();
        img.crossOrigin = 'anonymous';

        img.onload = function () {
          _this4.texture = createTexture2D({
            data: img,
            width: img.width,
            height: img.height,
            wrapS: gl.CLAMP_TO_EDGE,
            wrapT: gl.CLAMP_TO_EDGE
          });

          _this4.layerService.updateLayerRenderList();

          _this4.layerService.renderLayers();
        };

        img.src = mapTexture;
      } else {
        this.texture = createTexture2D({
          width: 0,
          height: 0
        });
      }
    }
  }, {
    key: "getConfigSchema",
    value: function getConfigSchema() {
      return {
        properties: {
          opacity: {
            type: 'number',
            minimum: 0,
            maximum: 1
          }
        }
      };
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      this.styleAttributeService.registerStyleAttribute({
        name: 'uv',
        type: AttributeType.Attribute,
        descriptor: {
          name: 'a_Uv',
          buffer: {
            usage: gl.DYNAMIC_DRAW,
            data: [],
            type: gl.FLOAT
          },
          size: 2,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            return [vertex[3], vertex[4]];
          }
        }
      });
    }
  }]);

  return PlaneModel;
}(BaseModel);

export { PlaneModel as default };
//# sourceMappingURL=plane.js.map