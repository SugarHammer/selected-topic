import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import { aProjectFlat } from '@antv/l7-utils';
import { vec2 } from 'gl-matrix';
var tmp = vec2.create();
var capEnd = vec2.create();
var lineA = vec2.create();
var lineB = vec2.create();
var tangent = vec2.create();
export function computeMiter(lineTangent, miter, start, end, halfThick) {
  vec2.add(lineTangent, start, end);
  vec2.normalize(lineTangent, lineTangent);
  miter = vec2.fromValues(-lineTangent[1], lineTangent[0]);
  var tmpvec = vec2.fromValues(-start[1], start[0]);
  return [halfThick / vec2.dot(miter, tmpvec), miter];
}
export function computeNormal(out, dir) {
  return vec2.set(out, -dir[1], dir[0]);
}
export function direction(out, a, b) {
  vec2.sub(out, a, b);
  vec2.normalize(out, out);
  return out;
}

function isPointEqual(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}

function getArrayUnique(matrix) {
  var map = new Map();

  for (var i = 0; i < matrix.length; i++) {
    var key = matrix[0].toString() + '-' + matrix[1].toString();

    if (map.get(key)) {
      matrix.splice(i, 1);
      i++;
    } else {
      map.set(key, key);
    }
  }

  return matrix;
}

var ExtrudePolyline = function () {
  function ExtrudePolyline() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, ExtrudePolyline);

    _defineProperty(this, "complex", void 0);

    _defineProperty(this, "join", void 0);

    _defineProperty(this, "cap", void 0);

    _defineProperty(this, "miterLimit", void 0);

    _defineProperty(this, "thickness", void 0);

    _defineProperty(this, "normal", void 0);

    _defineProperty(this, "lastFlip", -1);

    _defineProperty(this, "miter", vec2.fromValues(0, 0));

    _defineProperty(this, "started", false);

    _defineProperty(this, "dash", false);

    _defineProperty(this, "totalDistance", 0);

    this.join = opts.join || 'miter';
    this.cap = opts.cap || 'butt';
    this.miterLimit = opts.miterLimit || 10;
    this.thickness = opts.thickness || 1;
    this.dash = opts.dash || false;
    this.complex = {
      positions: [],
      indices: [],
      normals: [],
      startIndex: 0
    };
  }

  _createClass(ExtrudePolyline, [{
    key: "extrude_gaode2",
    value: function extrude_gaode2(points, originPoints) {
      var complex = this.complex;

      if (points.length <= 1) {
        return complex;
      }

      this.lastFlip = -1;
      this.started = false;
      this.normal = null;
      this.totalDistance = 0;
      var total = points.length;
      var count = complex.startIndex;

      for (var i = 1; i < total; i++) {
        var _originPoints$, _originPoints$i$, _originPoints$2;

        var last = points[i - 1];
        last.push((_originPoints$ = originPoints[i - 1][2]) !== null && _originPoints$ !== void 0 ? _originPoints$ : 0);
        var originLast = originPoints[i - 1];
        var cur = points[i];
        cur.push((_originPoints$i$ = originPoints[i][2]) !== null && _originPoints$i$ !== void 0 ? _originPoints$i$ : 0);
        var originCur = originPoints[i];
        var next = i < points.length - 1 ? [].concat(_toConsumableArray(points[i + 1]), [(_originPoints$2 = originPoints[i + 1][2]) !== null && _originPoints$2 !== void 0 ? _originPoints$2 : 0]) : null;
        var originNext = i < originPoints.length - 1 ? originPoints[i + 1] : null;
        var amt = this.segment_gaode2(complex, count, last, cur, next, originLast, originCur, originNext);
        count += amt;
      }

      if (this.dash) {
        for (var _i = 0; _i < complex.positions.length / 6; _i++) {
          complex.positions[_i * 6 + 5] = this.totalDistance;
        }
      }

      complex.startIndex = complex.positions.length / 6;
      return complex;
    }
  }, {
    key: "simpleExtrude_gaode2",
    value: function simpleExtrude_gaode2(points, originPoints) {
      var complex = this.complex;

      if (points.length <= 1) {
        return complex;
      }

      this.lastFlip = -1;
      this.started = false;
      this.normal = null;
      this.totalDistance = 0;
      var total = points.length;
      var count = complex.startIndex;

      for (var i = 1; i < total; i++) {
        var _originPoints$3, _originPoints$i$2, _originPoints$4;

        var last = points[i - 1];
        last.push((_originPoints$3 = originPoints[i - 1][2]) !== null && _originPoints$3 !== void 0 ? _originPoints$3 : 0);
        var originLast = originPoints[i - 1];
        var cur = points[i];
        cur.push((_originPoints$i$2 = originPoints[i][2]) !== null && _originPoints$i$2 !== void 0 ? _originPoints$i$2 : 0);
        var originCur = originPoints[i];
        var next = i < points.length - 1 ? [].concat(_toConsumableArray(points[i + 1]), [(_originPoints$4 = originPoints[i + 1][2]) !== null && _originPoints$4 !== void 0 ? _originPoints$4 : 0]) : null;
        var originNext = i < originPoints.length - 1 ? originPoints[i + 1] : null;
        var amt = this.simpleSegment(complex, count, last, cur, next, originLast, originCur, originNext);
        count += amt;
      }

      if (this.dash) {
        for (var _i2 = 0; _i2 < complex.positions.length / 6; _i2++) {
          complex.positions[_i2 * 6 + 5] = this.totalDistance;
        }
      }

      complex.startIndex = complex.positions.length / 6;
      return complex;
    }
  }, {
    key: "extrude",
    value: function extrude(points) {
      var complex = this.complex;

      if (points.length <= 1) {
        return complex;
      }

      this.lastFlip = -1;
      this.started = false;
      this.normal = null;
      this.totalDistance = 0;
      var total = points.length;
      var count = complex.startIndex;

      for (var i = 1; i < total; i++) {
        var last = points[i - 1];
        var cur = points[i];
        var next = i < points.length - 1 ? points[i + 1] : null;
        var amt = this.segment(complex, count, last, cur, next);
        count += amt;
      }

      if (this.dash) {
        for (var _i3 = 0; _i3 < complex.positions.length / 6; _i3++) {
          complex.positions[_i3 * 6 + 5] = this.totalDistance;
        }
      }

      complex.startIndex = complex.positions.length / 6;
      return complex;
    }
  }, {
    key: "simpleExtrude",
    value: function simpleExtrude(points) {
      var complex = this.complex;

      if (points.length <= 1) {
        return complex;
      }

      this.lastFlip = -1;
      this.started = false;
      this.normal = null;
      this.totalDistance = 0;
      var total = points.length;
      var count = complex.startIndex;

      for (var i = 1; i < total; i++) {
        var last = points[i - 1];
        var cur = points[i];
        var next = i < points.length - 1 ? points[i + 1] : null;
        var amt = this.simpleSegment(complex, count, last, cur, next);
        count += amt;
      }

      if (this.dash) {
        for (var _i4 = 0; _i4 < complex.positions.length / 6; _i4++) {
          complex.positions[_i4 * 6 + 5] = this.totalDistance;
        }
      }

      complex.startIndex = complex.positions.length / 6;
      return complex;
    }
  }, {
    key: "segment_gaode2",
    value: function segment_gaode2(complex, index, last, cur, next, originLast, originCur, originNext) {
      var count = 0;
      var indices = complex.indices;
      var positions = complex.positions;
      var normals = complex.normals;
      var capSquare = this.cap === 'square';
      var joinBevel = this.join === 'bevel';
      var flatCur = aProjectFlat([originCur[0], originCur[1]]);
      var flatLast = aProjectFlat([originLast[0], originLast[1]]);
      direction(lineA, cur, last);
      var segmentDistance = 0;

      if (this.dash) {
        segmentDistance = this.lineSegmentDistance(flatCur, flatLast);
        this.totalDistance += segmentDistance;
      }

      if (!this.normal) {
        this.normal = vec2.create();
        computeNormal(this.normal, lineA);
      }

      if (!this.started) {
        this.started = true;

        if (capSquare) {
          var out1 = vec2.create();
          var out2 = vec2.create();
          vec2.add(out1, this.normal, lineA);
          vec2.add(out2, this.normal, lineA);
          normals.push(out2[0], out2[1], 0);
          normals.push(out1[0], out1[1], 0);
          positions.push(last[0], last[1], last[2] | 0, this.totalDistance - segmentDistance, -this.thickness, last[2] | 0);
          positions.push(last[0], last[1], last[2] | 0, this.totalDistance - segmentDistance, this.thickness, last[2] | 0);
        } else {
          this.extrusions(positions, normals, last, this.normal, this.thickness, this.totalDistance - segmentDistance);
        }
      }

      indices.push(index + 0, index + 1, index + 2);

      if (!next) {
        computeNormal(this.normal, lineA);

        if (capSquare) {
          var _out = vec2.create();

          var _out2 = vec2.create();

          vec2.sub(_out2, lineA, this.normal);
          vec2.add(_out, lineA, this.normal);
          normals.push(_out2[0], _out2[1], 0);
          normals.push(_out[0], _out[1], 0);
          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness, cur[2] | 0);
          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness, cur[2] | 0);
        } else {
          this.extrusions(positions, normals, cur, this.normal, this.thickness, this.totalDistance);
        }

        indices.push.apply(indices, _toConsumableArray(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));
        count += 2;
      } else {
        if (isPointEqual(cur, next)) {
          vec2.add(next, cur, vec2.normalize(next, vec2.subtract(next, cur, last)));
        }

        direction(lineB, next, cur);

        var _computeMiter = computeMiter(tangent, vec2.create(), lineA, lineB, this.thickness),
            _computeMiter2 = _slicedToArray(_computeMiter, 2),
            miterLen = _computeMiter2[0],
            miter = _computeMiter2[1];

        var flip = vec2.dot(tangent, this.normal) < 0 ? -1 : 1;
        var bevel = joinBevel;

        if (!bevel && this.join === 'miter') {
          var limit = miterLen;

          if (limit > this.miterLimit) {
            bevel = true;
          }
        }

        if (bevel) {
          normals.push(this.normal[0], this.normal[1], 0);
          normals.push(miter[0], miter[1], 0);
          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, -this.thickness * flip, cur[2] | 0);
          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness * flip, cur[2] | 0);
          indices.push.apply(indices, _toConsumableArray(this.lastFlip !== -flip ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));
          indices.push(index + 2, index + 3, index + 4);
          computeNormal(tmp, lineB);
          vec2.copy(this.normal, tmp);
          normals.push(this.normal[0], this.normal[1], 0);
          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, -this.thickness * flip, cur[2] | 0);
          count += 3;
        } else {
          this.extrusions(positions, normals, cur, miter, miterLen, this.totalDistance);
          indices.push.apply(indices, _toConsumableArray(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));
          flip = -1;
          vec2.copy(this.normal, miter);
          count += 2;
        }

        this.lastFlip = flip;
      }

      return count;
    }
  }, {
    key: "simpleSegment",
    value: function simpleSegment(complex, index, last, cur, next) {
      var count = 0;
      var indices = complex.indices;
      var positions = complex.positions;
      var normals = complex.normals;
      var flatCur = aProjectFlat([cur[0], cur[1]]);
      var flatLast = aProjectFlat([last[0], last[1]]);
      direction(lineA, flatCur, flatLast);
      var segmentDistance = 0;

      if (this.dash) {
        segmentDistance = this.lineSegmentDistance(flatCur, flatLast);
        this.totalDistance += segmentDistance;
      }

      if (!this.normal) {
        this.normal = vec2.create();
        computeNormal(this.normal, lineA);
      }

      if (!this.started) {
        this.started = true;
        this.extrusions(positions, normals, last, this.normal, this.thickness, this.totalDistance - segmentDistance);
      }

      indices.push(index + 0, index + 1, index + 2);

      if (!next) {
        computeNormal(this.normal, lineA);
        this.extrusions(positions, normals, cur, this.normal, this.thickness, this.totalDistance);
        indices.push.apply(indices, _toConsumableArray(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));
        count += 2;
      } else {
        var flatNext = aProjectFlat([next[0], next[1]]);

        if (isPointEqual(flatCur, flatNext)) {
          vec2.add(flatNext, flatCur, vec2.normalize(flatNext, vec2.subtract(flatNext, flatCur, flatLast)));
        }

        direction(lineB, flatNext, flatCur);

        var _computeMiter3 = computeMiter(tangent, vec2.create(), lineA, lineB, this.thickness),
            _computeMiter4 = _slicedToArray(_computeMiter3, 2),
            miterLen = _computeMiter4[0],
            miter = _computeMiter4[1];

        var flip = vec2.dot(tangent, this.normal) < 0 ? -1 : 1;
        this.extrusions(positions, normals, cur, miter, miterLen, this.totalDistance);
        indices.push.apply(indices, _toConsumableArray(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));
        flip = -1;
        vec2.copy(this.normal, miter);
        count += 2;
        this.lastFlip = flip;
      }

      return count;
    }
  }, {
    key: "segment",
    value: function segment(complex, index, last, cur, next) {
      var count = 0;
      var indices = complex.indices;
      var positions = complex.positions;
      var normals = complex.normals;
      var capSquare = this.cap === 'square';
      var joinBevel = this.join === 'bevel';
      var flatCur = aProjectFlat([cur[0], cur[1]]);
      var flatLast = aProjectFlat([last[0], last[1]]);
      direction(lineA, flatCur, flatLast);
      var segmentDistance = 0;

      if (this.dash) {
        segmentDistance = this.lineSegmentDistance(flatCur, flatLast);
        this.totalDistance += segmentDistance;
      }

      if (!this.normal) {
        this.normal = vec2.create();
        computeNormal(this.normal, lineA);
      }

      if (!this.started) {
        this.started = true;

        if (capSquare) {
          var out1 = vec2.create();
          var out2 = vec2.create();
          vec2.add(out1, this.normal, lineA);
          vec2.add(out2, this.normal, lineA);
          normals.push(out2[0], out2[1], 0);
          normals.push(out1[0], out1[1], 0);
          positions.push(last[0], last[1], last[2] | 0, this.totalDistance - segmentDistance, -this.thickness, last[2] | 0);
          positions.push(last[0], last[1], last[2] | 0, this.totalDistance - segmentDistance, this.thickness, last[2] | 0);
        } else {
          this.extrusions(positions, normals, last, this.normal, this.thickness, this.totalDistance - segmentDistance);
        }
      }

      indices.push(index + 0, index + 1, index + 2);

      if (!next) {
        computeNormal(this.normal, lineA);

        if (capSquare) {
          var _out3 = vec2.create();

          var _out4 = vec2.create();

          vec2.sub(_out4, lineA, this.normal);
          vec2.add(_out3, lineA, this.normal);
          normals.push(_out4[0], _out4[1], 0);
          normals.push(_out3[0], _out3[1], 0);
          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness, cur[2] | 0);
          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness, cur[2] | 0);
        } else {
          this.extrusions(positions, normals, cur, this.normal, this.thickness, this.totalDistance);
        }

        indices.push.apply(indices, _toConsumableArray(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));
        count += 2;
      } else {
        var flatNext = aProjectFlat([next[0], next[1]]);

        if (isPointEqual(flatCur, flatNext)) {
          vec2.add(flatNext, flatCur, vec2.normalize(flatNext, vec2.subtract(flatNext, flatCur, flatLast)));
        }

        direction(lineB, flatNext, flatCur);

        var _computeMiter5 = computeMiter(tangent, vec2.create(), lineA, lineB, this.thickness),
            _computeMiter6 = _slicedToArray(_computeMiter5, 2),
            miterLen = _computeMiter6[0],
            miter = _computeMiter6[1];

        var flip = vec2.dot(tangent, this.normal) < 0 ? -1 : 1;
        var bevel = joinBevel;

        if (!bevel && this.join === 'miter') {
          var limit = miterLen;

          if (limit > this.miterLimit) {
            bevel = true;
          }
        }

        if (bevel) {
          normals.push(this.normal[0], this.normal[1], 0);
          normals.push(miter[0], miter[1], 0);
          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, -this.thickness * flip, cur[2] | 0);
          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness * flip, cur[2] | 0);
          indices.push.apply(indices, _toConsumableArray(this.lastFlip !== -flip ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));
          indices.push(index + 2, index + 3, index + 4);
          computeNormal(tmp, lineB);
          vec2.copy(this.normal, tmp);
          normals.push(this.normal[0], this.normal[1], 0);
          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, -this.thickness * flip, cur[2] | 0);
          count += 3;
        } else {
          this.extrusions(positions, normals, cur, miter, miterLen, this.totalDistance);
          indices.push.apply(indices, _toConsumableArray(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));
          flip = -1;
          vec2.copy(this.normal, miter);
          count += 2;
        }

        this.lastFlip = flip;
      }

      return count;
    }
  }, {
    key: "extrusions",
    value: function extrusions(positions, normals, point, normal, thickness, distanceRadio) {
      normals.push(normal[0], normal[1], 0);
      normals.push(normal[0], normal[1], 0);
      positions.push(point[0], point[1], point[2] | 0, distanceRadio, -thickness, point[2] | 0);
      positions.push(point[0], point[1], point[2] | 0, distanceRadio, thickness, point[2] | 0);
    }
  }, {
    key: "lineSegmentDistance",
    value: function lineSegmentDistance(b1, a1) {
      var dx = a1[0] - b1[0];
      var dy = a1[1] - b1[1];
      return Math.sqrt(dx * dx + dy * dy);
    }
  }]);

  return ExtrudePolyline;
}();

export { ExtrudePolyline as default };
//# sourceMappingURL=extrude_polyline.js.map