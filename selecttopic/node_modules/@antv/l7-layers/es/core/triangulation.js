import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import { lngLatToMeters } from '@antv/l7-utils';
import earcut from 'earcut';
import { vec3 } from 'gl-matrix';
import { EARTH_RADIUS, EARTH_RADIUS_OUTER, EARTH_SEGMENTS, lglt2xyz, primitiveSphere } from '../earth/utils';
import ExtrudePolyline from '../utils/extrude_polyline';
import { calculateCentroid, calculatePointsCenterAndRadius } from '../utils/geo';
import extrudePolygon, { extrude_PolygonNormal, fillPolygon } from './shape/extrude';
import { geometryShape } from './shape/Path';
var GeometryCache = {};
export function PointFillTriangulation(feature) {
  var coordinates = calculateCentroid(feature.coordinates);
  return {
    vertices: [].concat(_toConsumableArray(coordinates), _toConsumableArray(coordinates), _toConsumableArray(coordinates), _toConsumableArray(coordinates)),
    indices: [0, 1, 2, 2, 3, 0],
    size: coordinates.length
  };
}
export function GlobelPointFillTriangulation(feature) {
  var coordinates = calculateCentroid(feature.coordinates);
  var xyz = lglt2xyz(coordinates);
  return {
    vertices: [].concat(_toConsumableArray(xyz), _toConsumableArray(xyz), _toConsumableArray(xyz), _toConsumableArray(xyz)),
    indices: [0, 1, 2, 2, 3, 0],
    size: xyz.length
  };
}
export function PointExtrudeTriangulation(feature) {
  var shape = feature.shape;

  var _getGeometry = getGeometry(shape, false),
      positions = _getGeometry.positions,
      index = _getGeometry.index,
      normals = _getGeometry.normals;

  return {
    vertices: positions,
    indices: index,
    normals: normals,
    size: 5
  };
}
export function PointImageTriangulation(feature) {
  var coordinates = calculateCentroid(feature.coordinates);
  return {
    vertices: _toConsumableArray(coordinates),
    indices: [0],
    size: coordinates.length
  };
}
export function LineTriangulation(feature) {
  var coordinates = feature.coordinates,
      originCoordinates = feature.originCoordinates,
      version = feature.version;
  var line = new ExtrudePolyline({
    dash: true,
    join: 'bevel'
  });

  if (version === 'GAODE2.x') {
    var path1 = coordinates;

    if (!Array.isArray(path1[0][0])) {
      path1 = [coordinates];
    }

    var path2 = originCoordinates;

    if (!Array.isArray(path2[0][0])) {
      path2 = [originCoordinates];
    }

    for (var i = 0; i < path1.length; i++) {
      var item1 = path1[i];
      var item2 = path2[i];
      line.extrude_gaode2(item1, item2);
    }
  } else {
    var path = coordinates;

    if (path[0] && !Array.isArray(path[0][0])) {
      path = [coordinates];
    }

    path.forEach(function (item) {
      line.extrude(item);
    });
  }

  var linebuffer = line.complex;
  return {
    vertices: linebuffer.positions,
    indices: linebuffer.indices,
    normals: linebuffer.normals,
    size: 6
  };
}
export function SimpleLineTriangulation(feature) {
  var coordinates = feature.coordinates,
      originCoordinates = feature.originCoordinates,
      version = feature.version;
  var line = new ExtrudePolyline({
    dash: true,
    join: 'bevel'
  });

  if (version === 'GAODE2.x') {
    var path1 = coordinates;

    if (!Array.isArray(path1[0][0])) {
      path1 = [coordinates];
    }

    var path2 = originCoordinates;

    if (!Array.isArray(path2[0][0])) {
      path2 = [originCoordinates];
    }

    for (var i = 0; i < path1.length; i++) {
      var item1 = path1[i];
      var item2 = path2[i];
      line.simpleExtrude_gaode2(item1, item2);
    }
  } else {
    var path = coordinates;

    if (path[0] && !Array.isArray(path[0][0])) {
      path = [coordinates];
    }

    path.forEach(function (item) {
      line.simpleExtrude(item);
    });
  }

  var linebuffer = line.complex;
  return {
    vertices: linebuffer.positions,
    indices: linebuffer.indices,
    normals: linebuffer.normals,
    size: 6
  };
}
export function polygonTriangulation(feature) {
  var coordinates = feature.coordinates;
  var flattengeo = earcut.flatten(coordinates);
  var vertices = flattengeo.vertices,
      dimensions = flattengeo.dimensions,
      holes = flattengeo.holes;
  return {
    indices: earcut(vertices, holes, dimensions),
    vertices: vertices,
    size: dimensions
  };
}
export function polygonTriangulationWithCenter(feature) {
  var coordinates = feature.coordinates;
  var flattengeo = earcut.flatten(coordinates);
  var vertices = flattengeo.vertices,
      dimensions = flattengeo.dimensions,
      holes = flattengeo.holes;
  return {
    indices: earcut(vertices, holes, dimensions),
    vertices: getVerticesWithCenter(vertices),
    size: dimensions + 4
  };
}

function getVerticesWithCenter(vertices) {
  var verticesWithCenter = [];

  var _calculatePointsCente = calculatePointsCenterAndRadius(vertices),
      center = _calculatePointsCente.center,
      radius = _calculatePointsCente.radius;

  for (var i = 0; i < vertices.length; i += 2) {
    var lng = vertices[i];
    var lat = vertices[i + 1];
    verticesWithCenter.push.apply(verticesWithCenter, [lng, lat, 0].concat(_toConsumableArray(center), [radius]));
  }

  return verticesWithCenter;
}

export function PolygonExtrudeTriangulation(feature) {
  var coordinates = feature.coordinates;

  var _extrude_PolygonNorma = extrude_PolygonNormal(coordinates, true),
      positions = _extrude_PolygonNorma.positions,
      index = _extrude_PolygonNorma.index,
      normals = _extrude_PolygonNorma.normals;

  return {
    vertices: positions,
    indices: index,
    normals: normals,
    size: 5
  };
}
export function HeatmapGridTriangulation(feature) {
  var shape = feature.shape;

  var _getHeatmapGeometry = getHeatmapGeometry(shape),
      positions = _getHeatmapGeometry.positions,
      index = _getHeatmapGeometry.index;

  return {
    vertices: positions,
    indices: index,
    size: 3
  };
}
export function RasterImageTriangulation(feature) {
  var coordinates = feature.coordinates;
  var positions = [].concat(_toConsumableArray(coordinates[0]), [0, 0, 1, coordinates[1][0], coordinates[0][1], 0, 1, 1], _toConsumableArray(coordinates[1]), [0, 1, 0], _toConsumableArray(coordinates[0]), [0, 0, 1], _toConsumableArray(coordinates[1]), [0, 1, 0, coordinates[0][0], coordinates[1][1], 0, 0, 0]);
  var indexs = [0, 1, 2, 3, 4, 5];
  return {
    vertices: positions,
    indices: indexs,
    size: 5
  };
}
export function LineArcTriangulation(feature, segmentNumber) {
  var segNum = segmentNumber ? segmentNumber : 30;
  var coordinates = feature.coordinates;
  var positions = [];
  var indexArray = [];

  var _loop = function _loop(i) {
    positions.push(i, 1, i, coordinates[0][0], coordinates[0][1], coordinates[1][0], coordinates[1][1], i, -1, i, coordinates[0][0], coordinates[0][1], coordinates[1][0], coordinates[1][1]);

    if (i !== segNum - 1) {
      indexArray.push.apply(indexArray, _toConsumableArray([0, 1, 2, 1, 3, 2].map(function (v) {
        return i * 2 + v;
      })));
    }
  };

  for (var i = 0; i < segNum; i++) {
    _loop(i);
  }

  return {
    vertices: positions,
    indices: indexArray,
    size: 7
  };
}
export function HeatmapTriangulation(feature) {
  var coordinates = feature.coordinates;

  if (coordinates.length === 2) {
    coordinates.push(0);
  }

  var size = feature.size;
  var dir = addDir(-1, 1);
  var dir1 = addDir(1, 1);
  var dir2 = addDir(-1, -1);
  var dir3 = addDir(1, -1);
  var positions = [].concat(_toConsumableArray(coordinates), _toConsumableArray(dir), _toConsumableArray(coordinates), _toConsumableArray(dir2), _toConsumableArray(coordinates), _toConsumableArray(dir3), _toConsumableArray(coordinates), _toConsumableArray(dir1));
  var indexArray = [0, 1, 2, 3, 0, 2];
  return {
    vertices: positions,
    indices: indexArray,
    size: 5
  };
}

function getGeometry(shape) {
  var needFlat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (GeometryCache && GeometryCache[shape]) {
    return GeometryCache[shape];
  }

  var path = geometryShape[shape] ? geometryShape[shape]() : geometryShape.cylinder();
  var geometry = extrude_PolygonNormal([path], needFlat);
  GeometryCache[shape] = geometry;
  return geometry;
}

function computeVertexNormals(positions, indexArray) {
  var dim = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3;
  var needFlat = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var normals = new Float32Array(positions.length / dim * 3);
  var vA;
  var vB;
  var vC;
  var cb = vec3.create();
  var ab = vec3.create();
  var normal = vec3.create();

  for (var i = 0, li = indexArray.length; i < li; i += 3) {
    vA = indexArray[i + 0] * 3;
    vB = indexArray[i + 1] * 3;
    vC = indexArray[i + 2] * 3;
    var p1 = [positions[vA], positions[vA + 1]];
    var p2 = [positions[vB], positions[vB + 1]];
    var p3 = [positions[vC], positions[vC + 1]];

    if (needFlat) {
      p1 = lngLatToMeters(p1);
      p2 = lngLatToMeters(p2);
      p3 = lngLatToMeters(p3);
    }

    var _p = p1,
        _p2 = _slicedToArray(_p, 2),
        ax = _p2[0],
        ay = _p2[1];

    var pA = vec3.fromValues(ax, ay, positions[vA + 2]);

    var _p3 = p2,
        _p4 = _slicedToArray(_p3, 2),
        bx = _p4[0],
        by = _p4[1];

    var pB = vec3.fromValues(bx, by, positions[vB + 2]);

    var _p5 = p3,
        _p6 = _slicedToArray(_p5, 2),
        cx = _p6[0],
        cy = _p6[1];

    var pC = vec3.fromValues(cx, cy, positions[vC + 2]);
    vec3.sub(cb, pC, pB);
    vec3.sub(ab, pA, pB);
    vec3.cross(normal, cb, ab);
    normals[vA] += cb[0];
    normals[vA + 1] += cb[1];
    normals[vA + 2] += cb[2];
    normals[vB] += cb[0];
    normals[vB + 1] += cb[1];
    normals[vB + 2] += cb[2];
    normals[vC] += cb[0];
    normals[vC + 1] += cb[1];
    normals[vC + 2] += cb[2];
  }

  normalizeNormals(normals);
  return normals;
}

function normalizeNormals(normals) {
  for (var i = 0, li = normals.length; i < li; i += 3) {
    var normal = vec3.fromValues(normals[i], normals[i + 1], normals[i + 2]);
    var newNormal = vec3.create();
    vec3.normalize(newNormal, normal);
    normals.set(newNormal, i);
  }
}

function checkIsClosed(points) {
  var p1 = points[0][0];
  var p2 = points[0][points[0].length - 1];
  return p1[0] === p2[0] && p1[1] === p2[1];
}

function getHeatmapGeometry(shape) {
  var shape3d = ['cylinder', 'triangleColumn', 'hexagonColumn', 'squareColumn'];
  var path = geometryShape[shape] ? geometryShape[shape]() : geometryShape.circle();
  var geometry = shape3d.indexOf(shape) === -1 ? fillPolygon([path]) : extrudePolygon([path]);
  return geometry;
}

function addDir(dirX, dirY) {
  var x = (dirX + 1) / 2;
  var y = (dirY + 1) / 2;
  return [x, y];
}

export function earthTriangulation() {
  var earthmesh = primitiveSphere(EARTH_RADIUS, {
    segments: EARTH_SEGMENTS
  });
  var positionsArr = earthmesh.positionsArr,
      indicesArr = earthmesh.indicesArr,
      normalArr = earthmesh.normalArr;
  return {
    vertices: positionsArr,
    indices: indicesArr,
    size: 5,
    normals: normalArr
  };
}
export function earthOuterTriangulation() {
  var earthmesh = primitiveSphere(EARTH_RADIUS + EARTH_RADIUS_OUTER, {
    segments: EARTH_SEGMENTS
  });
  var positionsArr = earthmesh.positionsArr,
      indicesArr = earthmesh.indicesArr,
      normalArr = earthmesh.normalArr;
  return {
    vertices: positionsArr,
    indices: indicesArr,
    size: 5,
    normals: normalArr
  };
}
//# sourceMappingURL=triangulation.js.map