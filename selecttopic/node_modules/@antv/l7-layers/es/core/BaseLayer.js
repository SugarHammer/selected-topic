import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
import _initializerDefineProperty from "@babel/runtime/helpers/initializerDefineProperty";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _assertThisInitialized from "@babel/runtime/helpers/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _applyDecoratedDescriptor from "@babel/runtime/helpers/applyDecoratedDescriptor";
import _initializerWarningHelper from "@babel/runtime/helpers/initializerWarningHelper";
import _isUndefined from "lodash/isUndefined";
import _isObject from "lodash/isObject";
import _isFunction from "lodash/isFunction";
var _excluded = ["passes"],
    _excluded2 = ["moduleName", "vertexShader", "fragmentShader", "triangulation", "segmentNumber"];

var _dec, _class, _descriptor;

import _regeneratorRuntime from "@babel/runtime/regenerator";

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

import { SyncBailHook, SyncHook, SyncWaterfallHook } from '@antv/async-hook';
import { BlendType, lazyInject, TYPES } from '@antv/l7-core';
import { encodePickingColor } from '@antv/l7-utils';
import { EventEmitter } from 'eventemitter3';
import { BlendTypes } from '../utils/blend';
import { handleStyleDataMapping } from '../utils/dataMappingStyle';
import { createMultiPassRenderer, normalizePasses } from '../utils/multiPassRender';
import { updateShape } from '../utils/updateShape';
var layerIdCounter = 0;
var BaseLayer = (_dec = lazyInject(TYPES.IGlobalConfigService), (_class = function (_EventEmitter) {
  _inherits(BaseLayer, _EventEmitter);

  var _super = _createSuper(BaseLayer);

  function BaseLayer() {
    var _this;

    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, BaseLayer);

    _this = _super.call(this);

    _defineProperty(_assertThisInitialized(_this), "id", "".concat(layerIdCounter++));

    _defineProperty(_assertThisInitialized(_this), "name", "".concat(layerIdCounter));

    _defineProperty(_assertThisInitialized(_this), "type", void 0);

    _defineProperty(_assertThisInitialized(_this), "visible", true);

    _defineProperty(_assertThisInitialized(_this), "zIndex", 0);

    _defineProperty(_assertThisInitialized(_this), "minZoom", void 0);

    _defineProperty(_assertThisInitialized(_this), "maxZoom", void 0);

    _defineProperty(_assertThisInitialized(_this), "inited", false);

    _defineProperty(_assertThisInitialized(_this), "layerModelNeedUpdate", false);

    _defineProperty(_assertThisInitialized(_this), "pickedFeatureID", null);

    _defineProperty(_assertThisInitialized(_this), "selectedFeatureID", null);

    _defineProperty(_assertThisInitialized(_this), "styleNeedUpdate", false);

    _defineProperty(_assertThisInitialized(_this), "rendering", void 0);

    _defineProperty(_assertThisInitialized(_this), "clusterZoom", 0);

    _defineProperty(_assertThisInitialized(_this), "layerType", void 0);

    _defineProperty(_assertThisInitialized(_this), "dataState", {
      dataSourceNeedUpdate: false,
      dataMappingNeedUpdate: false,
      filterNeedUpdate: false,
      featureScaleNeedUpdate: false,
      StyleAttrNeedUpdate: false
    });

    _defineProperty(_assertThisInitialized(_this), "hooks", {
      init: new SyncBailHook(),
      afterInit: new SyncBailHook(),
      beforeRender: new SyncBailHook(),
      beforeRenderData: new SyncWaterfallHook(),
      afterRender: new SyncHook(),
      beforePickingEncode: new SyncHook(),
      afterPickingEncode: new SyncHook(),
      beforeHighlight: new SyncHook(['pickedColor']),
      afterHighlight: new SyncHook(),
      beforeSelect: new SyncHook(['pickedColor']),
      afterSelect: new SyncHook(),
      beforeDestroy: new SyncHook(),
      afterDestroy: new SyncHook()
    });

    _defineProperty(_assertThisInitialized(_this), "models", []);

    _defineProperty(_assertThisInitialized(_this), "multiPassRenderer", void 0);

    _defineProperty(_assertThisInitialized(_this), "plugins", void 0);

    _defineProperty(_assertThisInitialized(_this), "sourceOption", void 0);

    _defineProperty(_assertThisInitialized(_this), "layerModel", void 0);

    _defineProperty(_assertThisInitialized(_this), "shapeOption", void 0);

    _defineProperty(_assertThisInitialized(_this), "sceneContainer", void 0);

    _defineProperty(_assertThisInitialized(_this), "layerChildren", []);

    _initializerDefineProperty(_assertThisInitialized(_this), "configService", _descriptor, _assertThisInitialized(_this));

    _defineProperty(_assertThisInitialized(_this), "shaderModuleService", void 0);

    _defineProperty(_assertThisInitialized(_this), "cameraService", void 0);

    _defineProperty(_assertThisInitialized(_this), "coordinateService", void 0);

    _defineProperty(_assertThisInitialized(_this), "iconService", void 0);

    _defineProperty(_assertThisInitialized(_this), "fontService", void 0);

    _defineProperty(_assertThisInitialized(_this), "pickingService", void 0);

    _defineProperty(_assertThisInitialized(_this), "rendererService", void 0);

    _defineProperty(_assertThisInitialized(_this), "layerService", void 0);

    _defineProperty(_assertThisInitialized(_this), "interactionService", void 0);

    _defineProperty(_assertThisInitialized(_this), "mapService", void 0);

    _defineProperty(_assertThisInitialized(_this), "styleAttributeService", void 0);

    _defineProperty(_assertThisInitialized(_this), "layerSource", void 0);

    _defineProperty(_assertThisInitialized(_this), "postProcessingPassFactory", void 0);

    _defineProperty(_assertThisInitialized(_this), "normalPassFactory", void 0);

    _defineProperty(_assertThisInitialized(_this), "animateOptions", {
      enable: false
    });

    _defineProperty(_assertThisInitialized(_this), "container", void 0);

    _defineProperty(_assertThisInitialized(_this), "encodedData", void 0);

    _defineProperty(_assertThisInitialized(_this), "configSchema", void 0);

    _defineProperty(_assertThisInitialized(_this), "currentPickId", null);

    _defineProperty(_assertThisInitialized(_this), "rawConfig", void 0);

    _defineProperty(_assertThisInitialized(_this), "needUpdateConfig", void 0);

    _defineProperty(_assertThisInitialized(_this), "pendingStyleAttributes", []);

    _defineProperty(_assertThisInitialized(_this), "scaleOptions", {});

    _defineProperty(_assertThisInitialized(_this), "animateStartTime", void 0);

    _defineProperty(_assertThisInitialized(_this), "aniamateStatus", false);

    _defineProperty(_assertThisInitialized(_this), "bottomColor", 'rgba(0, 0, 0, 0)');

    _defineProperty(_assertThisInitialized(_this), "isDestroied", false);

    _defineProperty(_assertThisInitialized(_this), "sourceEvent", function () {
      _this.dataState.dataSourceNeedUpdate = true;

      var _this$getLayerConfig = _this.getLayerConfig(),
          autoFit = _this$getLayerConfig.autoFit,
          fitBoundsOptions = _this$getLayerConfig.fitBoundsOptions;

      if (autoFit) {
        _this.fitBounds(fitBoundsOptions);
      }

      _this.emit('dataUpdate');

      _this.reRender();
    });

    _this.name = config.name || _this.id;
    _this.zIndex = config.zIndex || 0;
    _this.rawConfig = config;
    return _this;
  }

  _createClass(BaseLayer, [{
    key: "getLayerConfig",
    value: function getLayerConfig() {
      return this.configService.getLayerConfig(this.id);
    }
  }, {
    key: "updateLayerConfig",
    value: function updateLayerConfig(configToUpdate) {
      if (!this.inited) {
        this.needUpdateConfig = _objectSpread(_objectSpread({}, this.needUpdateConfig), configToUpdate);
      } else {
        var sceneId = this.container.get(TYPES.SceneID);
        handleStyleDataMapping(configToUpdate, this);
        this.configService.setLayerConfig(sceneId, this.id, _objectSpread(_objectSpread(_objectSpread({}, this.configService.getLayerConfig(this.id)), this.needUpdateConfig), configToUpdate));
        this.needUpdateConfig = {};
      }
    }
  }, {
    key: "setContainer",
    value: function setContainer(container, sceneContainer) {
      this.container = container;
      this.sceneContainer = sceneContainer;
    }
  }, {
    key: "getContainer",
    value: function getContainer() {
      return this.container;
    }
  }, {
    key: "setBottomColor",
    value: function setBottomColor(color) {
      this.bottomColor = color;
    }
  }, {
    key: "getBottomColor",
    value: function getBottomColor() {
      return this.bottomColor;
    }
  }, {
    key: "addPlugin",
    value: function addPlugin(plugin) {
      this.plugins.push(plugin);
      return this;
    }
  }, {
    key: "init",
    value: function init() {
      var _this2 = this;

      var sceneId = this.container.get(TYPES.SceneID);
      this.configService.setLayerConfig(sceneId, this.id, this.rawConfig);
      this.layerType = this.rawConfig.layerType;
      this.iconService = this.container.get(TYPES.IIconService);
      this.fontService = this.container.get(TYPES.IFontService);
      this.rendererService = this.container.get(TYPES.IRendererService);
      this.layerService = this.container.get(TYPES.ILayerService);
      this.interactionService = this.container.get(TYPES.IInteractionService);
      this.pickingService = this.container.get(TYPES.IPickingService);
      this.mapService = this.container.get(TYPES.IMapService);

      var _this$getLayerConfig2 = this.getLayerConfig(),
          enableMultiPassRenderer = _this$getLayerConfig2.enableMultiPassRenderer,
          passes = _this$getLayerConfig2.passes;

      if (enableMultiPassRenderer && passes !== null && passes !== void 0 && passes.length && passes.length > 0) {
        this.mapService.on('mapAfterFrameChange', function () {
          _this2.renderLayers();
        });
      }

      this.cameraService = this.container.get(TYPES.ICameraService);
      this.coordinateService = this.container.get(TYPES.ICoordinateSystemService);
      this.shaderModuleService = this.container.get(TYPES.IShaderModuleService);
      this.postProcessingPassFactory = this.container.get(TYPES.IFactoryPostProcessingPass);
      this.normalPassFactory = this.container.get(TYPES.IFactoryNormalPass);
      this.styleAttributeService = this.container.get(TYPES.IStyleAttributeService);
      this.multiPassRenderer = this.container.get(TYPES.IMultiPassRenderer);
      this.multiPassRenderer.setLayer(this);
      this.pendingStyleAttributes.forEach(function (_ref) {
        var attributeName = _ref.attributeName,
            attributeField = _ref.attributeField,
            attributeValues = _ref.attributeValues,
            updateOptions = _ref.updateOptions;

        _this2.styleAttributeService.updateStyleAttribute(attributeName, {
          scale: _objectSpread({
            field: attributeField
          }, _this2.splitValuesAndCallbackInAttribute(attributeValues, _this2.getLayerConfig()[attributeName]))
        }, updateOptions);
      });
      this.pendingStyleAttributes = [];
      this.plugins = this.container.getAll(TYPES.ILayerPlugin);

      var _iterator = _createForOfIteratorHelper(this.plugins),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var plugin = _step.value;
          plugin.apply(this, {
            rendererService: this.rendererService,
            mapService: this.mapService,
            styleAttributeService: this.styleAttributeService,
            normalPassFactory: this.normalPassFactory,
            postProcessingPassFactory: this.postProcessingPassFactory
          });
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      this.hooks.init.call();
      this.hooks.afterInit.call();
      this.emit('inited', {
        target: this,
        type: 'inited'
      });
      this.emit('add', {
        target: this,
        type: 'add'
      });
      return this;
    }
  }, {
    key: "prepareBuildModel",
    value: function prepareBuildModel() {
      this.inited = true;
      this.updateLayerConfig(_objectSpread(_objectSpread({}, this.getDefaultConfig()), this.rawConfig));

      var _this$getLayerConfig3 = this.getLayerConfig(),
          animateOption = _this$getLayerConfig3.animateOption;

      if (animateOption !== null && animateOption !== void 0 && animateOption.enable) {
        this.layerService.startAnimate();
        this.aniamateStatus = true;
      }
    }
  }, {
    key: "color",
    value: function color(field, values, updateOptions) {
      this.updateStyleAttribute('color', field, values, updateOptions);
      return this;
    }
  }, {
    key: "texture",
    value: function texture(field, values, updateOptions) {
      this.updateStyleAttribute('texture', field, values, updateOptions);
      return this;
    }
  }, {
    key: "rotate",
    value: function rotate(field, values, updateOptions) {
      this.updateStyleAttribute('rotate', field, values, updateOptions);
      return this;
    }
  }, {
    key: "size",
    value: function size(field, values, updateOptions) {
      this.updateStyleAttribute('size', field, values, updateOptions);
      return this;
    }
  }, {
    key: "filter",
    value: function filter(field, values, updateOptions) {
      this.updateStyleAttribute('filter', field, values, updateOptions);
      return this;
    }
  }, {
    key: "shape",
    value: function shape(field, values, updateOptions) {
      var _this$styleAttributeS, _this$styleAttributeS2, _this$styleAttributeS3;

      var lastShape = (_this$styleAttributeS = this.styleAttributeService) === null || _this$styleAttributeS === void 0 ? void 0 : (_this$styleAttributeS2 = _this$styleAttributeS.getLayerStyleAttribute('shape')) === null || _this$styleAttributeS2 === void 0 ? void 0 : (_this$styleAttributeS3 = _this$styleAttributeS2.scale) === null || _this$styleAttributeS3 === void 0 ? void 0 : _this$styleAttributeS3.field;
      var currentShape = field;
      this.shapeOption = {
        field: field,
        values: values
      };
      this.updateStyleAttribute('shape', field, values, updateOptions);
      updateShape(this, lastShape, currentShape);
      return this;
    }
  }, {
    key: "label",
    value: function label(field, values, updateOptions) {
      this.pendingStyleAttributes.push({
        attributeName: 'label',
        attributeField: field,
        attributeValues: values,
        updateOptions: updateOptions
      });
      return this;
    }
  }, {
    key: "animate",
    value: function animate(options) {
      var rawAnimate = {};

      if (_isObject(options)) {
        rawAnimate.enable = true;
        rawAnimate = _objectSpread(_objectSpread({}, rawAnimate), options);
      } else {
        rawAnimate.enable = options;
      }

      this.updateLayerConfig({
        animateOption: rawAnimate
      });
      return this;
    }
  }, {
    key: "source",
    value: function source(data, options) {
      if (data !== null && data !== void 0 && data.data) {
        this.setSource(data);
        return this;
      }

      this.sourceOption = {
        data: data,
        options: options
      };
      this.clusterZoom = 0;
      return this;
    }
  }, {
    key: "setData",
    value: function setData(data, options) {
      var _this3 = this;

      if (this.inited) {
        this.layerSource.setData(data, options);
      } else {
        this.on('inited', function () {
          _this3.layerSource.setData(data, options);
        });
      }

      return this;
    }
  }, {
    key: "style",
    value: function style(options) {
      var _this4 = this;

      var passes = options.passes,
          rest = _objectWithoutProperties(options, _excluded);

      if (passes) {
        normalizePasses(passes).forEach(function (pass) {
          var postProcessingPass = _this4.multiPassRenderer.getPostProcessor().getPostProcessingPassByName(pass[0]);

          if (postProcessingPass) {
            postProcessingPass.updateOptions(pass[1]);
          }
        });
      }

      this.rawConfig = _objectSpread(_objectSpread({}, this.rawConfig), rest);

      if (this.container) {
        this.updateLayerConfig(this.rawConfig);
        this.styleNeedUpdate = true;
      }

      return this;
    }
  }, {
    key: "scale",
    value: function scale(field, cfg) {
      if (_isObject(field)) {
        this.scaleOptions = _objectSpread(_objectSpread({}, this.scaleOptions), field);
      } else {
        this.scaleOptions[field] = cfg;
      }

      return this;
    }
  }, {
    key: "renderLayers",
    value: function renderLayers() {
      this.rendering = true;
      this.layerService.renderLayers();
      this.rendering = false;
    }
  }, {
    key: "render",
    value: function render() {
      if (this.getEncodedData().length !== 0) {
        this.renderModels();
      }

      return this;
    }
  }, {
    key: "renderMultiPass",
    value: function () {
      var _renderMultiPass = _asyncToGenerator(_regeneratorRuntime.mark(function _callee() {
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(this.getEncodedData().length !== 0)) {
                  _context.next = 7;
                  break;
                }

                if (!(this.multiPassRenderer && this.multiPassRenderer.getRenderFlag())) {
                  _context.next = 6;
                  break;
                }

                _context.next = 4;
                return this.multiPassRenderer.render();

              case 4:
                _context.next = 7;
                break;

              case 6:
                if (this.multiPassRenderer) {
                  this.renderModels();
                } else {
                  this.renderModels();
                }

              case 7:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function renderMultiPass() {
        return _renderMultiPass.apply(this, arguments);
      }

      return renderMultiPass;
    }()
  }, {
    key: "active",
    value: function active(options) {
      var activeOption = {};
      activeOption.enableHighlight = _isObject(options) ? true : options;

      if (_isObject(options)) {
        activeOption.enableHighlight = true;

        if (options.color) {
          activeOption.highlightColor = options.color;
        }

        if (options.mix) {
          activeOption.activeMix = options.mix;
        }
      } else {
        activeOption.enableHighlight = !!options;
      }

      this.updateLayerConfig(activeOption);
      return this;
    }
  }, {
    key: "setActive",
    value: function setActive(id, options) {
      var _this5 = this;

      if (_isObject(id)) {
        var _id$x = id.x,
            x = _id$x === void 0 ? 0 : _id$x,
            _id$y = id.y,
            y = _id$y === void 0 ? 0 : _id$y;
        this.updateLayerConfig({
          highlightColor: _isObject(options) ? options.color : this.getLayerConfig().highlightColor,
          activeMix: _isObject(options) ? options.mix : this.getLayerConfig().activeMix
        });
        this.pick({
          x: x,
          y: y
        });
      } else {
        this.updateLayerConfig({
          pickedFeatureID: id,
          highlightColor: _isObject(options) ? options.color : this.getLayerConfig().highlightColor,
          activeMix: _isObject(options) ? options.mix : this.getLayerConfig().activeMix
        });
        this.hooks.beforeSelect.call(encodePickingColor(id)).then(function () {
          setTimeout(function () {
            _this5.reRender();
          }, 1);
        });
      }
    }
  }, {
    key: "select",
    value: function select(option) {
      var activeOption = {};
      activeOption.enableSelect = _isObject(option) ? true : option;

      if (_isObject(option)) {
        activeOption.enableSelect = true;

        if (option.color) {
          activeOption.selectColor = option.color;
        }

        if (option.mix) {
          activeOption.selectMix = option.mix;
        }
      } else {
        activeOption.enableSelect = !!option;
      }

      this.updateLayerConfig(activeOption);
      return this;
    }
  }, {
    key: "setSelect",
    value: function setSelect(id, options) {
      var _this6 = this;

      if (_isObject(id)) {
        var _id$x2 = id.x,
            x = _id$x2 === void 0 ? 0 : _id$x2,
            _id$y2 = id.y,
            y = _id$y2 === void 0 ? 0 : _id$y2;
        this.updateLayerConfig({
          selectColor: _isObject(options) ? options.color : this.getLayerConfig().selectColor,
          selectMix: _isObject(options) ? options.mix : this.getLayerConfig().selectMix
        });
        this.pick({
          x: x,
          y: y
        });
      } else {
        this.updateLayerConfig({
          pickedFeatureID: id,
          selectColor: _isObject(options) ? options.color : this.getLayerConfig().selectColor,
          selectMix: _isObject(options) ? options.mix : this.getLayerConfig().selectMix
        });
        this.hooks.beforeSelect.call(encodePickingColor(id)).then(function () {
          setTimeout(function () {
            _this6.reRender();
          }, 1);
        });
      }
    }
  }, {
    key: "setBlend",
    value: function setBlend(type) {
      this.updateLayerConfig({
        blend: type
      });
      this.layerModelNeedUpdate = true;
      this.reRender();
      return this;
    }
  }, {
    key: "show",
    value: function show() {
      this.updateLayerConfig({
        visible: true
      });
      this.reRender();
      return this;
    }
  }, {
    key: "hide",
    value: function hide() {
      this.updateLayerConfig({
        visible: false
      });
      this.reRender();
      return this;
    }
  }, {
    key: "setIndex",
    value: function setIndex(index) {
      this.zIndex = index;
      this.layerService.updateLayerRenderList();
      this.layerService.renderLayers();
      return this;
    }
  }, {
    key: "setCurrentPickId",
    value: function setCurrentPickId(id) {
      this.currentPickId = id;
    }
  }, {
    key: "getCurrentPickId",
    value: function getCurrentPickId() {
      return this.currentPickId;
    }
  }, {
    key: "setCurrentSelectedId",
    value: function setCurrentSelectedId(id) {
      this.selectedFeatureID = id;
    }
  }, {
    key: "getCurrentSelectedId",
    value: function getCurrentSelectedId() {
      return this.selectedFeatureID;
    }
  }, {
    key: "isVisible",
    value: function isVisible() {
      var zoom = this.mapService.getZoom();

      var _this$getLayerConfig4 = this.getLayerConfig(),
          visible = _this$getLayerConfig4.visible,
          _this$getLayerConfig5 = _this$getLayerConfig4.minZoom,
          minZoom = _this$getLayerConfig5 === void 0 ? -Infinity : _this$getLayerConfig5,
          _this$getLayerConfig6 = _this$getLayerConfig4.maxZoom,
          maxZoom = _this$getLayerConfig6 === void 0 ? Infinity : _this$getLayerConfig6;

      return !!visible && zoom >= minZoom && zoom <= maxZoom;
    }
  }, {
    key: "setMultiPass",
    value: function setMultiPass(enableMultiPass, currentPasses) {
      this.updateLayerConfig({
        enableMultiPassRenderer: enableMultiPass
      });

      if (currentPasses) {
        this.updateLayerConfig({
          passes: currentPasses
        });
      }

      if (enableMultiPass) {
        var _this$getLayerConfig7 = this.getLayerConfig(),
            _this$getLayerConfig8 = _this$getLayerConfig7.passes,
            passes = _this$getLayerConfig8 === void 0 ? [] : _this$getLayerConfig8;

        this.multiPassRenderer = createMultiPassRenderer(this, passes, this.postProcessingPassFactory, this.normalPassFactory);
        this.multiPassRenderer.setRenderFlag(true);

        var _this$rendererService = this.rendererService.getViewportSize(),
            width = _this$rendererService.width,
            height = _this$rendererService.height;

        this.multiPassRenderer.resize(width, height);
      }

      return this;
    }
  }, {
    key: "setMinZoom",
    value: function setMinZoom(minZoom) {
      this.updateLayerConfig({
        minZoom: minZoom
      });
      return this;
    }
  }, {
    key: "getMinZoom",
    value: function getMinZoom() {
      var _this$getLayerConfig9 = this.getLayerConfig(),
          minZoom = _this$getLayerConfig9.minZoom;

      return minZoom;
    }
  }, {
    key: "getMaxZoom",
    value: function getMaxZoom() {
      var _this$getLayerConfig10 = this.getLayerConfig(),
          maxZoom = _this$getLayerConfig10.maxZoom;

      return maxZoom;
    }
  }, {
    key: "get",
    value: function get(name) {
      var cfg = this.getLayerConfig();
      return cfg[name];
    }
  }, {
    key: "setMaxZoom",
    value: function setMaxZoom(maxZoom) {
      this.updateLayerConfig({
        maxZoom: maxZoom
      });
      return this;
    }
  }, {
    key: "setAutoFit",
    value: function setAutoFit(autoFit) {
      this.updateLayerConfig({
        autoFit: autoFit
      });
      return this;
    }
  }, {
    key: "fitBounds",
    value: function fitBounds(fitBoundsOptions) {
      if (!this.inited) {
        this.updateLayerConfig({
          autoFit: true
        });
        return this;
      }

      var source = this.getSource();
      var extent = source.extent;
      var isValid = extent.some(function (v) {
        return Math.abs(v) === Infinity;
      });

      if (isValid) {
        return this;
      }

      this.mapService.fitBounds([[extent[0], extent[1]], [extent[2], extent[3]]], fitBoundsOptions);
      return this;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.isDestroied) {
        return;
      }

      this.hooks.beforeDestroy.call();
      this.layerSource.off('update', this.sourceEvent);
      this.multiPassRenderer.destroy();
      this.styleAttributeService.clearAllAttributes();
      this.hooks.afterDestroy.call();
      this.models = [];
      this.layerService.cleanRemove(this);
      this.emit('remove', {
        target: this,
        type: 'remove'
      });
      this.emit('destroy', {
        target: this,
        type: 'destroy'
      });
      this.removeAllListeners();
      this.isDestroied = true;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.styleAttributeService.clearAllAttributes();
    }
  }, {
    key: "clearModels",
    value: function clearModels() {
      this.models.forEach(function (model) {
        return model.destroy();
      });
      this.layerModel.clearModels();
    }
  }, {
    key: "isDirty",
    value: function isDirty() {
      return !!(this.styleAttributeService.getLayerStyleAttributes() || []).filter(function (attribute) {
        return attribute.needRescale || attribute.needRemapping || attribute.needRegenerateVertices;
      }).length;
    }
  }, {
    key: "setSource",
    value: function setSource(source) {
      if (this.layerSource) {
        this.layerSource.off('update', this.sourceEvent);
      }

      this.layerSource = source;
      this.clusterZoom = 0;

      if (this.inited && this.layerSource.cluster) {
        var zoom = this.mapService.getZoom();
        this.layerSource.updateClusterData(zoom);
      }

      this.layerSource.on('update', this.sourceEvent);
    }
  }, {
    key: "getSource",
    value: function getSource() {
      return this.layerSource;
    }
  }, {
    key: "getScaleOptions",
    value: function getScaleOptions() {
      return this.scaleOptions;
    }
  }, {
    key: "setEncodedData",
    value: function setEncodedData(encodedData) {
      this.encodedData = encodedData;
    }
  }, {
    key: "getEncodedData",
    value: function getEncodedData() {
      return this.encodedData;
    }
  }, {
    key: "getScale",
    value: function getScale(name) {
      return this.styleAttributeService.getLayerAttributeScale(name);
    }
  }, {
    key: "getLegendItems",
    value: function getLegendItems(name) {
      var scale = this.styleAttributeService.getLayerAttributeScale(name);

      if (!scale) {
        return [];
      }

      if (scale.invertExtent) {
        var items = scale.range().map(function (item) {
          return _defineProperty({
            value: scale.invertExtent(item)
          }, name, item);
        });
        return items;
      } else if (scale.ticks) {
        var _items = scale.ticks().map(function (item) {
          return _defineProperty({
            value: item
          }, name, scale(item));
        });

        return _items;
      } else if (scale !== null && scale !== void 0 && scale.domain) {
        var _items2 = scale.domain().filter(function (item) {
          return !_isUndefined(item);
        }).map(function (item) {
          return _defineProperty({
            value: item
          }, name, scale(item));
        });

        return _items2;
      }

      return [];
    }
  }, {
    key: "pick",
    value: function pick(_ref5) {
      var x = _ref5.x,
          y = _ref5.y;
      this.interactionService.triggerHover({
        x: x,
        y: y
      });
    }
  }, {
    key: "boxSelect",
    value: function boxSelect(box, cb) {
      this.pickingService.boxPickLayer(this, box, cb);
    }
  }, {
    key: "buildLayerModel",
    value: function buildLayerModel(options) {
      var moduleName = options.moduleName,
          vertexShader = options.vertexShader,
          fragmentShader = options.fragmentShader,
          triangulation = options.triangulation,
          segmentNumber = options.segmentNumber,
          rest = _objectWithoutProperties(options, _excluded2);

      this.shaderModuleService.registerModule(moduleName, {
        vs: vertexShader,
        fs: fragmentShader
      });

      var _this$shaderModuleSer = this.shaderModuleService.getModule(moduleName),
          vs = _this$shaderModuleSer.vs,
          fs = _this$shaderModuleSer.fs,
          uniforms = _this$shaderModuleSer.uniforms;

      var createModel = this.rendererService.createModel;

      var _this$styleAttributeS4 = this.styleAttributeService.createAttributesAndIndices(this.encodedData, triangulation, segmentNumber),
          attributes = _this$styleAttributeS4.attributes,
          elements = _this$styleAttributeS4.elements;

      return createModel(_objectSpread({
        attributes: attributes,
        uniforms: uniforms,
        fs: fs,
        vs: vs,
        elements: elements,
        blend: BlendTypes[BlendType.normal]
      }, rest));
    }
  }, {
    key: "getTime",
    value: function getTime() {
      return this.layerService.clock.getDelta();
    }
  }, {
    key: "setAnimateStartTime",
    value: function setAnimateStartTime() {
      this.animateStartTime = this.layerService.clock.getElapsedTime();
    }
  }, {
    key: "stopAnimate",
    value: function stopAnimate() {
      if (this.aniamateStatus) {
        this.layerService.stopAnimate();
        this.aniamateStatus = false;
        this.updateLayerConfig({
          animateOption: {
            enable: false
          }
        });
      }
    }
  }, {
    key: "getLayerAnimateTime",
    value: function getLayerAnimateTime() {
      return this.layerService.clock.getElapsedTime() - this.animateStartTime;
    }
  }, {
    key: "needPick",
    value: function needPick(type) {
      var _this$getLayerConfig11 = this.getLayerConfig(),
          _this$getLayerConfig12 = _this$getLayerConfig11.enableHighlight,
          enableHighlight = _this$getLayerConfig12 === void 0 ? true : _this$getLayerConfig12,
          _this$getLayerConfig13 = _this$getLayerConfig11.enableSelect,
          enableSelect = _this$getLayerConfig13 === void 0 ? true : _this$getLayerConfig13;

      var isPick = this.eventNames().indexOf(type) !== -1 || this.eventNames().indexOf('un' + type) !== -1;

      if ((type === 'click' || type === 'dblclick') && enableSelect) {
        isPick = true;
      }

      if (type === 'mousemove' && (enableHighlight || this.eventNames().indexOf('mouseenter') !== -1 || this.eventNames().indexOf('unmousemove') !== -1 || this.eventNames().indexOf('mouseout') !== -1)) {
        isPick = true;
      }

      return this.isVisible() && isPick;
    }
  }, {
    key: "buildModels",
    value: function buildModels() {
      throw new Error('Method not implemented.');
    }
  }, {
    key: "rebuildModels",
    value: function rebuildModels() {
      throw new Error('Method not implemented.');
    }
  }, {
    key: "renderMulPass",
    value: function () {
      var _renderMulPass = _asyncToGenerator(_regeneratorRuntime.mark(function _callee2(multiPassRenderer) {
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return multiPassRenderer.render();

              case 2:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      function renderMulPass(_x) {
        return _renderMulPass.apply(this, arguments);
      }

      return renderMulPass;
    }()
  }, {
    key: "renderModels",
    value: function renderModels(isPicking) {
      var _this7 = this;

      if (this.getEncodedData().length > 0) {
        if (this.layerModelNeedUpdate && this.layerModel) {
          this.models = this.layerModel.buildModels();
          this.hooks.beforeRender.call();
          this.layerModelNeedUpdate = false;
        }

        if (this.layerModel.renderUpdate) {
          this.layerModel.renderUpdate();
        }

        this.models.forEach(function (model) {
          model.draw({
            uniforms: _this7.layerModel.getUninforms()
          }, isPicking);
        });
      }

      return this;
    }
  }, {
    key: "updateStyleAttribute",
    value: function updateStyleAttribute(type, field, values, updateOptions) {
      if (!this.inited) {
        this.pendingStyleAttributes.push({
          attributeName: type,
          attributeField: field,
          attributeValues: values,
          updateOptions: updateOptions
        });
      } else {
        this.styleAttributeService.updateStyleAttribute(type, {
          scale: _objectSpread({
            field: field
          }, this.splitValuesAndCallbackInAttribute(values, this.getLayerConfig()[field]))
        }, updateOptions);
      }
    }
  }, {
    key: "getShaderPickStat",
    value: function getShaderPickStat() {
      return this.layerService.getShaderPickStat();
    }
  }, {
    key: "setEarthTime",
    value: function setEarthTime(time) {
      console.warn('empty fn');
    }
  }, {
    key: "getConfigSchema",
    value: function getConfigSchema() {
      throw new Error('Method not implemented.');
    }
  }, {
    key: "getModelType",
    value: function getModelType() {
      throw new Error('Method not implemented.');
    }
  }, {
    key: "getDefaultConfig",
    value: function getDefaultConfig() {
      return {};
    }
  }, {
    key: "reRender",
    value: function reRender() {
      if (this.inited) {
        this.layerService.updateLayerRenderList();
        this.layerService.renderLayers();
      }
    }
  }, {
    key: "splitValuesAndCallbackInAttribute",
    value: function splitValuesAndCallbackInAttribute(valuesOrCallback, defaultValues) {
      return {
        values: _isFunction(valuesOrCallback) ? undefined : valuesOrCallback || defaultValues,
        callback: _isFunction(valuesOrCallback) ? valuesOrCallback : undefined
      };
    }
  }]);

  return BaseLayer;
}(EventEmitter), (_descriptor = _applyDecoratedDescriptor(_class.prototype, "configService", [_dec], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
})), _class));
export { BaseLayer as default };
//# sourceMappingURL=BaseLayer.js.map