import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import { mat4, vec3 } from 'gl-matrix';
export var EARTH_RADIUS = 100;
export var EARTH_SEGMENTS = 36;
export var EARTH_RADIUS_OUTER = 40;

function torad(deg) {
  return deg / 180 * Math.acos(-1);
}

export function lglt2xyz(lnglat) {
  var lng = torad(lnglat[0]) + Math.PI / 2;
  var lat = torad(lnglat[1]);
  var radius = EARTH_RADIUS + Math.random() * 0.4;
  var z = radius * Math.cos(lat) * Math.cos(lng);
  var x = radius * Math.cos(lat) * Math.sin(lng);
  var y = radius * Math.sin(lat);
  return [x, y, z];
}
export function primitiveSphere(radius, opt) {
  var matRotY = mat4.create();
  var matRotZ = mat4.create();
  var up = vec3.fromValues(0, 1, 0);
  var tmpVec3 = vec3.fromValues(0, 0, 0);
  opt = opt || {};
  radius = typeof radius !== 'undefined' ? radius : 1;
  var segments = typeof opt.segments !== 'undefined' ? opt.segments : 32;
  var totalZRotationSteps = 2 + segments;
  var totalYRotationSteps = 2 * totalZRotationSteps;
  var indices = [];
  var indicesArr = [];
  var positions = [];
  var positionsArr = [];
  var normalArr = [];
  var uvs = [];

  for (var zRotationStep = 0; zRotationStep <= totalZRotationSteps; zRotationStep++) {
    var normalizedZ = zRotationStep / totalZRotationSteps;
    var angleZ = normalizedZ * Math.PI;

    for (var yRotationStep = 0; yRotationStep <= totalYRotationSteps; yRotationStep++) {
      var normalizedY = yRotationStep / totalYRotationSteps;
      var angleY = normalizedY * Math.PI * 2;
      mat4.identity(matRotZ);
      mat4.rotateZ(matRotZ, matRotZ, -angleZ);
      mat4.identity(matRotY);
      mat4.rotateY(matRotY, matRotY, angleY);
      vec3.transformMat4(tmpVec3, up, matRotZ);
      vec3.transformMat4(tmpVec3, tmpVec3, matRotY);
      vec3.scale(tmpVec3, tmpVec3, -radius);
      positions.push(tmpVec3.slice());
      positionsArr.push.apply(positionsArr, _toConsumableArray(tmpVec3.slice()));
      vec3.normalize(tmpVec3, tmpVec3);
      normalArr.push.apply(normalArr, _toConsumableArray(tmpVec3.slice()));
      uvs.push([normalizedY, 1 - normalizedZ]);
      positionsArr.push(normalizedY, 1 - normalizedZ);
    }

    if (zRotationStep > 0) {
      var verticesCount = positions.length;
      var firstIndex = verticesCount - 2 * (totalYRotationSteps + 1);

      for (; firstIndex + totalYRotationSteps + 2 < verticesCount; firstIndex++) {
        indices.push([firstIndex, firstIndex + 1, firstIndex + totalYRotationSteps + 1]);
        indicesArr.push(firstIndex, firstIndex + 1, firstIndex + totalYRotationSteps + 1);
        indices.push([firstIndex + totalYRotationSteps + 1, firstIndex + 1, firstIndex + totalYRotationSteps + 2]);
        indicesArr.push(firstIndex + totalYRotationSteps + 1, firstIndex + 1, firstIndex + totalYRotationSteps + 2);
      }
    }
  }

  return {
    cells: indices,
    positions: positions,
    uvs: uvs,
    positionsArr: positionsArr,
    indicesArr: indicesArr,
    normalArr: normalArr
  };
}
//# sourceMappingURL=utils.js.map