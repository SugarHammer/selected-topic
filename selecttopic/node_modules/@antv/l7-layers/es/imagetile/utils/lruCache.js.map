{"version":3,"sources":["../../../src/imagetile/utils/lruCache.ts"],"names":["LRUCache","limit","destroy","order","clear","forEach","key","delete","cache","value","deleteOrder","appendOrder","Object","keys","length","deleteCache","index","findIndex","o","splice","push"],"mappings":";;;;IAOqBA,Q;AAKnB,sBAA4C;AAAA,QAAhCC,KAAgC,uEAAxB,EAAwB;AAAA,QAApBC,OAAoB,uEAAV;AAAA,aAAM,EAAN;AAAA,KAAU;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAC1C,SAAKD,KAAL,GAAaA,KAAb;AACA,SAAKC,OAAL,GAAeA,OAAf;AACA,SAAKC,KAAL,GAAa,EAAb;AACA,SAAKC,KAAL;AACD;;;;WAED,iBAAe;AAAA;;AACb,WAAKD,KAAL,CAAWE,OAAX,CAAmB,UAACC,GAAD,EAAc;AAC/B,QAAA,KAAI,CAACC,MAAL,CAAYD,GAAZ;AACD,OAFD;AAGA,WAAKE,KAAL,GAAa,EAAb;AAEA,WAAKL,KAAL,GAAa,EAAb;AACD;;;WAED,aAAWG,GAAX,EAAwB;AACtB,UAAMG,KAAK,GAAG,KAAKD,KAAL,CAAWF,GAAX,CAAd;;AACA,UAAIG,KAAJ,EAAW;AAET,aAAKC,WAAL,CAAiBJ,GAAjB;AACA,aAAKK,WAAL,CAAiBL,GAAjB;AACD;;AACD,aAAOG,KAAP;AACD;;;WAED,aAAWH,GAAX,EAAwBG,KAAxB,EAAoC;AAClC,UAAI,CAAC,KAAKD,KAAL,CAAWF,GAAX,CAAL,EAAsB;AAEpB,YAAIM,MAAM,CAACC,IAAP,CAAY,KAAKL,KAAjB,EAAwBM,MAAxB,KAAmC,KAAKb,KAA5C,EAAmD;AACjD,eAAKM,MAAL,CAAY,KAAKJ,KAAL,CAAW,CAAX,CAAZ;AACD;;AAED,aAAKK,KAAL,CAAWF,GAAX,IAAkBG,KAAlB;AACA,aAAKE,WAAL,CAAiBL,GAAjB;AACD,OARD,MAQO;AAEL,aAAKC,MAAL,CAAYD,GAAZ;AAEA,aAAKE,KAAL,CAAWF,GAAX,IAAkBG,KAAlB;AACA,aAAKE,WAAL,CAAiBL,GAAjB;AACD;AACF;;;WAED,iBAAcA,GAAd,EAA2B;AACzB,UAAMG,KAAK,GAAG,KAAKD,KAAL,CAAWF,GAAX,CAAd;;AACA,UAAIG,KAAJ,EAAW;AACT,aAAKM,WAAL,CAAiBT,GAAjB;AACA,aAAKI,WAAL,CAAiBJ,GAAjB;AACA,aAAKJ,OAAL,CAAaO,KAAb,EAAoBH,GAApB;AACD;AACF;;;WAED,qBAAmBA,GAAnB,EAAgC;AAC9B,aAAO,KAAKE,KAAL,CAAWF,GAAX,CAAP;AACD;;;WAED,qBAAmBA,GAAnB,EAAgC;AAC9B,UAAMU,KAAK,GAAG,KAAKb,KAAL,CAAWc,SAAX,CAAqB,UAACC,CAAD;AAAA,eAAOA,CAAC,KAAKZ,GAAb;AAAA,OAArB,CAAd;;AACA,UAAIU,KAAK,IAAI,CAAb,EAAgB;AACd,aAAKb,KAAL,CAAWgB,MAAX,CAAkBH,KAAlB,EAAyB,CAAzB;AACD;AACF;;;WAED,qBAAmBV,GAAnB,EAAgC;AAC9B,WAAKH,KAAL,CAAWiB,IAAX,CAAgBd,GAAhB;AACD;;;;;;SAvEkBN,Q","sourcesContent":["/**\n * LRU Cache class with limit\n *\n * Update order for each get/set operation\n * Delete oldest when reach given limit\n */\n\nexport default class LRUCache {\n  public limit: number;\n  public order: any[];\n  public cache: any;\n  public destroy: any;\n  constructor(limit = 50, destroy = () => '') {\n    this.limit = limit;\n    this.destroy = destroy;\n    this.order = [];\n    this.clear();\n  }\n\n  public clear() {\n    this.order.forEach((key: any) => {\n      this.delete(key);\n    });\n    this.cache = {};\n    // access/update order, first item is oldest, last item is newest\n    this.order = [];\n  }\n\n  public get(key: string) {\n    const value = this.cache[key];\n    if (value) {\n      // update order\n      this.deleteOrder(key);\n      this.appendOrder(key);\n    }\n    return value;\n  }\n\n  public set(key: string, value: any) {\n    if (!this.cache[key]) {\n      // if reach limit, delete the oldest\n      if (Object.keys(this.cache).length === this.limit) {\n        this.delete(this.order[0]);\n      }\n\n      this.cache[key] = value;\n      this.appendOrder(key);\n    } else {\n      // if found in cache, delete the old one, insert new one to the first of list\n      this.delete(key);\n\n      this.cache[key] = value;\n      this.appendOrder(key);\n    }\n  }\n\n  public delete(key: string) {\n    const value = this.cache[key];\n    if (value) {\n      this.deleteCache(key);\n      this.deleteOrder(key);\n      this.destroy(value, key);\n    }\n  }\n\n  public deleteCache(key: string) {\n    delete this.cache[key];\n  }\n\n  public deleteOrder(key: string) {\n    const index = this.order.findIndex((o) => o === key);\n    if (index >= 0) {\n      this.order.splice(index, 1);\n    }\n  }\n\n  public appendOrder(key: string) {\n    this.order.push(key);\n  }\n}\n"],"file":"lruCache.js"}