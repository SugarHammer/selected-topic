import _construct from "@babel/runtime/helpers/construct";
import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _initializerDefineProperty from "@babel/runtime/helpers/initializerDefineProperty";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _applyDecoratedDescriptor from "@babel/runtime/helpers/applyDecoratedDescriptor";
import _initializerWarningHelper from "@babel/runtime/helpers/initializerWarningHelper";
var _excluded = ["id", "style", "minZoom", "maxZoom", "token", "mapInstance", "plugin"];

var _dec, _dec2, _dec3, _dec4, _dec5, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4;

import _regeneratorRuntime from "@babel/runtime/regenerator";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

import AMapLoader from '@amap/amap-jsapi-loader';
import { CoordinateSystem, MapServiceEvent, TYPES } from '@antv/l7-core';
import { DOM } from '@antv/l7-utils';
import { mat4, vec3 } from 'gl-matrix';
import { inject, injectable } from 'inversify';
import 'reflect-metadata';
import { SimpleMapCoord } from '../simpleMapCoord';
import { toPaddingOptions } from '../utils';
import { Version } from '../version';

function loadStyles(css, doc) {
  var isMiniAli = typeof my !== 'undefined' && !!my && typeof my.showToast === 'function' && my.isFRM !== true;
  var isWeChatMiniProgram = typeof wx !== 'undefined' && wx !== null && (typeof wx.request !== 'undefined' || typeof wx.miniProgram !== 'undefined');

  if (isMiniAli || isWeChatMiniProgram) {
    return;
  }

  if (!doc) doc = document;

  if (!doc) {
    return;
  }

  var head = doc.head || doc.getElementsByTagName('head')[0];

  if (!head) {
    head = doc.createElement('head');
    var body = doc.body || doc.getElementsByTagName('body')[0];

    if (body) {
      body.parentNode.insertBefore(head, body);
    } else {
      doc.documentElement.appendChild(head);
    }
  }

  var style = doc.createElement('style');
  style.type = 'text/css';

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(doc.createTextNode(css));
  }

  head.appendChild(style);
  return style;
}

loadStyles(".amap-logo{\n display: none !important;\n}\n");
import { MapTheme } from './theme';
import Viewport from './Viewport';
var mapdivCount = 0;
window.forceWebGL = true;
var AMAP_API_KEY = '15cd8a57710d40c9b7c0e3cc120f1200';
var AMAP_VERSION = '1.4.15';
var AMAP_SCRIPT_ID = 'amap-script';
var amapLoaded = false;
var pendingResolveQueue = [];
var LNGLAT_OFFSET_ZOOM_THRESHOLD = 12;
var AMapService = (_dec = injectable(), _dec2 = inject(TYPES.IGlobalConfigService), _dec3 = inject(TYPES.MapConfig), _dec4 = inject(TYPES.ICoordinateSystemService), _dec5 = inject(TYPES.IEventEmitter), _dec(_class = (_class2 = function () {
  function AMapService() {
    var _this = this;

    _classCallCheck(this, AMapService);

    _defineProperty(this, "version", Version['GAODE1.x']);

    _defineProperty(this, "simpleMapCoord", new SimpleMapCoord());

    _defineProperty(this, "map", void 0);

    _defineProperty(this, "bgColor", 'rgba(0, 0, 0, 0)');

    _initializerDefineProperty(this, "configService", _descriptor, this);

    _initializerDefineProperty(this, "config", _descriptor2, this);

    _initializerDefineProperty(this, "coordinateSystemService", _descriptor3, this);

    _initializerDefineProperty(this, "eventEmitter", _descriptor4, this);

    _defineProperty(this, "markerContainer", void 0);

    _defineProperty(this, "$mapContainer", void 0);

    _defineProperty(this, "viewport", void 0);

    _defineProperty(this, "cameraChangedCallback", void 0);

    _defineProperty(this, "handleCameraChanged", function (e) {
      var _e$camera = e.camera,
          fov = _e$camera.fov,
          near = _e$camera.near,
          far = _e$camera.far,
          height = _e$camera.height,
          pitch = _e$camera.pitch,
          rotation = _e$camera.rotation,
          aspect = _e$camera.aspect,
          position = _e$camera.position;

      var _this$getCenter = _this.getCenter(),
          lng = _this$getCenter.lng,
          lat = _this$getCenter.lat;

      _this.emit('mapchange');

      if (_this.cameraChangedCallback) {
        _this.viewport.syncWithMapCamera({
          aspect: aspect,
          bearing: 360 - rotation,
          far: far,
          fov: fov,
          cameraHeight: height,
          near: near,
          pitch: pitch,
          zoom: _this.map.getZoom() - 1,
          center: [lng, lat],
          offsetOrigin: [position.x, position.y]
        });

        var _this$config$offsetZo = _this.config.offsetZoom,
            offsetZoom = _this$config$offsetZo === void 0 ? LNGLAT_OFFSET_ZOOM_THRESHOLD : _this$config$offsetZo;

        if (_this.viewport.getZoom() > offsetZoom) {
          _this.coordinateSystemService.setCoordinateSystem(CoordinateSystem.P20_OFFSET);
        } else {
          _this.coordinateSystemService.setCoordinateSystem(CoordinateSystem.P20);
        }

        _this.cameraChangedCallback(_this.viewport);
      }
    });
  }

  _createClass(AMapService, [{
    key: "setBgColor",
    value: function setBgColor(color) {
      this.bgColor = color;
    }
  }, {
    key: "addMarkerContainer",
    value: function addMarkerContainer() {
      var mapContainer = this.map.getContainer();

      if (mapContainer !== null) {
        var amap = mapContainer.getElementsByClassName('amap-maps')[0];
        this.markerContainer = DOM.create('div', 'l7-marker-container', amap);
      }
    }
  }, {
    key: "getMarkerContainer",
    value: function getMarkerContainer() {
      return this.markerContainer;
    }
  }, {
    key: "on",
    value: function on(type, handler) {
      if (MapServiceEvent.indexOf(type) !== -1) {
        this.eventEmitter.on(type, handler);
      } else {
        this.map.on(type, handler);
      }
    }
  }, {
    key: "off",
    value: function off(type, handler) {
      if (MapServiceEvent.indexOf(type) !== -1) {
        this.eventEmitter.off(type, handler);
      } else {
        this.map.off(type, handler);
      }
    }
  }, {
    key: "getContainer",
    value: function getContainer() {
      return this.map.getContainer();
    }
  }, {
    key: "getMapCanvasContainer",
    value: function getMapCanvasContainer() {
      var _this$map$getContaine;

      return (_this$map$getContaine = this.map.getContainer()) === null || _this$map$getContaine === void 0 ? void 0 : _this$map$getContaine.getElementsByClassName('amap-maps')[0];
    }
  }, {
    key: "getSize",
    value: function getSize() {
      var size = this.map.getSize();
      return [size.getWidth(), size.getHeight()];
    }
  }, {
    key: "getType",
    value: function getType() {
      return 'amap';
    }
  }, {
    key: "getZoom",
    value: function getZoom() {
      return this.map.getZoom() - 1;
    }
  }, {
    key: "setZoom",
    value: function setZoom(zoom) {
      return this.map.setZoom(zoom + 1);
    }
  }, {
    key: "getCenter",
    value: function getCenter(options) {
      if (options !== null && options !== void 0 && options.padding) {
        var originCenter = this.getCenter();

        var _this$getSize = this.getSize(),
            _this$getSize2 = _slicedToArray(_this$getSize, 2),
            w = _this$getSize2[0],
            h = _this$getSize2[1];

        var padding = toPaddingOptions(options.padding);
        var px = this.lngLatToPixel([originCenter.lng, originCenter.lat]);
        var offsetPx = [(padding.right - padding.left) / 2, (padding.bottom - padding.top) / 2];
        var newCenter = this.pixelToLngLat([px.x - offsetPx[0], px.y - offsetPx[1]]);
        return newCenter;
      }

      var center = this.map.getCenter();
      return {
        lng: center.getLng(),
        lat: center.getLat()
      };
    }
  }, {
    key: "setCenter",
    value: function setCenter(lnglat, options) {
      if (options !== null && options !== void 0 && options.padding) {
        var padding = toPaddingOptions(options.padding);
        var px = this.lngLatToPixel(lnglat);
        var offsetPx = [(padding.right - padding.left) / 2, (padding.bottom - padding.top) / 2];
        var newCenter = this.pixelToLngLat([px.x + offsetPx[0], px.y + offsetPx[1]]);
        this.map.setCenter([newCenter.lng, newCenter.lat]);
      } else {
        this.map.setCenter(lnglat);
      }
    }
  }, {
    key: "getPitch",
    value: function getPitch() {
      return this.map.getPitch();
    }
  }, {
    key: "getRotation",
    value: function getRotation() {
      return 360 - this.map.getRotation();
    }
  }, {
    key: "getBounds",
    value: function getBounds() {
      var amapBound = this.map.getBounds().toBounds();
      var NE = amapBound.getNorthEast();
      var SW = amapBound.getSouthWest();
      var center = this.getCenter();
      var maxlng = center.lng > NE.getLng() || center.lng < SW.getLng() ? 180 - NE.getLng() : NE.getLng();
      var minlng = center.lng < SW.getLng() ? SW.getLng() - 180 : SW.getLng();
      return [[minlng, SW.getLat()], [maxlng, NE.getLat()]];
    }
  }, {
    key: "getMinZoom",
    value: function getMinZoom() {
      var zooms = this.map.get('zooms');
      return zooms[0] - 1;
    }
  }, {
    key: "getMaxZoom",
    value: function getMaxZoom() {
      var zooms = this.map.get('zooms');
      return zooms[1] - 1;
    }
  }, {
    key: "setRotation",
    value: function setRotation(rotation) {
      return this.map.setRotation(rotation);
    }
  }, {
    key: "setPitch",
    value: function setPitch(pitch) {
      return this.map.setPitch(pitch);
    }
  }, {
    key: "zoomIn",
    value: function zoomIn() {
      this.map.zoomIn();
    }
  }, {
    key: "zoomOut",
    value: function zoomOut() {
      this.map.zoomOut();
    }
  }, {
    key: "panTo",
    value: function panTo(p) {
      this.map.panTo(p);
    }
  }, {
    key: "panBy",
    value: function panBy() {
      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      this.map.panBy(x, y);
    }
  }, {
    key: "fitBounds",
    value: function fitBounds(extent) {
      this.map.setBounds(new AMap.Bounds([extent[0][0], extent[0][1], extent[1][0], extent[1][1]]));
    }
  }, {
    key: "setZoomAndCenter",
    value: function setZoomAndCenter(zoom, center) {
      this.map.setZoomAndCenter(zoom, center);
    }
  }, {
    key: "setMapStyle",
    value: function setMapStyle(style) {
      this.map.setMapStyle(this.getMapStyle(style));
    }
  }, {
    key: "setMapStatus",
    value: function setMapStatus(option) {
      this.map.setStatus(option);
    }
  }, {
    key: "pixelToLngLat",
    value: function pixelToLngLat(pixel) {
      var lngLat = this.map.pixelToLngLat(new AMap.Pixel(pixel[0], pixel[1]));
      return {
        lng: lngLat.getLng(),
        lat: lngLat.getLat()
      };
    }
  }, {
    key: "lngLatToPixel",
    value: function lngLatToPixel(lnglat) {
      var p = this.map.lnglatToPixel(new AMap.LngLat(lnglat[0], lnglat[1]));
      return {
        x: p.getX(),
        y: p.getY()
      };
    }
  }, {
    key: "containerToLngLat",
    value: function containerToLngLat(pixel) {
      var ll = new AMap.Pixel(pixel[0], pixel[1]);
      var lngLat = this.map.containerToLngLat(ll);
      return {
        lng: lngLat === null || lngLat === void 0 ? void 0 : lngLat.getLng(),
        lat: lngLat === null || lngLat === void 0 ? void 0 : lngLat.getLat()
      };
    }
  }, {
    key: "lngLatToContainer",
    value: function lngLatToContainer(lnglat) {
      var ll = new AMap.LngLat(lnglat[0], lnglat[1]);
      var pixel = this.map.lngLatToContainer(ll);
      return {
        x: pixel.getX(),
        y: pixel.getY()
      };
    }
  }, {
    key: "lngLatToCoord",
    value: function lngLatToCoord(lnglat) {
      var _this$map$lngLatToGeo = this.map.lngLatToGeodeticCoord(lnglat),
          x = _this$map$lngLatToGeo.x,
          y = _this$map$lngLatToGeo.y;

      return [x, -y];
    }
  }, {
    key: "lngLatToMercator",
    value: function lngLatToMercator(lnglat, altitude) {
      return {
        x: 0,
        y: 0,
        z: 0
      };
    }
  }, {
    key: "getModelMatrix",
    value: function getModelMatrix(lnglat, altitude, rotate) {
      var scale = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [1, 1, 1];
      var origin = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {
        x: 0,
        y: 0,
        z: 0
      };
      var flat = this.viewport.projectFlat(lnglat);
      var modelMatrix = mat4.create();
      mat4.translate(modelMatrix, modelMatrix, vec3.fromValues(flat[0], flat[1], altitude));
      mat4.scale(modelMatrix, modelMatrix, vec3.fromValues(scale[0], scale[1], scale[2]));
      mat4.rotateX(modelMatrix, modelMatrix, rotate[0]);
      mat4.rotateY(modelMatrix, modelMatrix, rotate[1]);
      mat4.rotateZ(modelMatrix, modelMatrix, rotate[2]);
      return modelMatrix;
    }
  }, {
    key: "init",
    value: function () {
      var _init = _asyncToGenerator(_regeneratorRuntime.mark(function _callee() {
        var _this2 = this;

        var _this$config, id, _this$config$style, style, _this$config$minZoom, minZoom, _this$config$maxZoom, maxZoom, _this$config$token, token, mapInstance, _this$config$plugin, plugin, rest;

        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _this$config = this.config, id = _this$config.id, _this$config$style = _this$config.style, style = _this$config$style === void 0 ? 'light' : _this$config$style, _this$config$minZoom = _this$config.minZoom, minZoom = _this$config$minZoom === void 0 ? 0 : _this$config$minZoom, _this$config$maxZoom = _this$config.maxZoom, maxZoom = _this$config$maxZoom === void 0 ? 18 : _this$config$maxZoom, _this$config$token = _this$config.token, token = _this$config$token === void 0 ? AMAP_API_KEY : _this$config$token, mapInstance = _this$config.mapInstance, _this$config$plugin = _this$config.plugin, plugin = _this$config$plugin === void 0 ? [] : _this$config$plugin, rest = _objectWithoutProperties(_this$config, _excluded);
                _context.next = 3;
                return new Promise(function (resolve) {
                  var resolveMap = function resolveMap() {
                    if (mapInstance) {
                      _this2.map = mapInstance;
                      _this2.$mapContainer = _this2.map.getContainer();
                      setTimeout(function () {
                        _this2.map.on('camerachange', _this2.handleCameraChanged);

                        resolve();
                      }, 30);
                    } else {
                      _this2.$mapContainer = _this2.creatAmapContainer(id);

                      var mapConstructorOptions = _objectSpread({
                        mapStyle: _this2.getMapStyle(style),
                        zooms: [minZoom, maxZoom],
                        viewMode: '3D'
                      }, rest);

                      if (mapConstructorOptions.zoom) {
                        mapConstructorOptions.zoom += 1;
                      }

                      var map = new AMap.Map(_this2.$mapContainer, mapConstructorOptions);
                      map.on('camerachange', _this2.handleCameraChanged);
                      map.on('camerachange', function () {
                        setTimeout(function () {
                          return _this2.handleAfterMapChange();
                        });
                      });
                      _this2.map = map;
                      setTimeout(function () {
                        resolve();
                      }, 10);
                    }
                  };

                  if (!amapLoaded && !mapInstance) {
                    if (token === AMAP_API_KEY) {
                      console.warn(_this2.configService.getSceneWarninfo('MapToken'));
                    }

                    amapLoaded = true;
                    plugin.push('Map3D');
                    AMapLoader.load({
                      key: token,
                      version: AMAP_VERSION,
                      plugins: plugin
                    }).then(function (AMap) {
                      resolveMap();

                      if (pendingResolveQueue.length) {
                        pendingResolveQueue.forEach(function (r) {
                          return r();
                        });
                        pendingResolveQueue = [];
                      }
                    }).catch(function (e) {
                      throw new Error(e);
                    });
                  } else {
                    if (amapLoaded && window.AMap || mapInstance) {
                      resolveMap();
                    } else {
                      pendingResolveQueue.push(resolveMap);
                    }
                  }
                });

              case 3:
                this.viewport = new Viewport();

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function init() {
        return _init.apply(this, arguments);
      }

      return init;
    }()
  }, {
    key: "meterToCoord",
    value: function meterToCoord(center, outer) {
      var meterDis = AMap.GeometryUtil.distance(_construct(AMap.LngLat, _toConsumableArray(center)), _construct(AMap.LngLat, _toConsumableArray(outer)));

      var _this$lngLatToCoord = this.lngLatToCoord(center),
          _this$lngLatToCoord2 = _slicedToArray(_this$lngLatToCoord, 2),
          x1 = _this$lngLatToCoord2[0],
          y1 = _this$lngLatToCoord2[1];

      var _this$lngLatToCoord3 = this.lngLatToCoord(outer),
          _this$lngLatToCoord4 = _slicedToArray(_this$lngLatToCoord3, 2),
          x2 = _this$lngLatToCoord4[0],
          y2 = _this$lngLatToCoord4[1];

      var coordDis = Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
      return coordDis / meterDis;
    }
  }, {
    key: "exportMap",
    value: function exportMap(type) {
      var _this$getContainer;

      var renderCanvas = (_this$getContainer = this.getContainer()) === null || _this$getContainer === void 0 ? void 0 : _this$getContainer.getElementsByClassName('amap-layer')[0];
      var layersPng = type === 'jpg' ? renderCanvas === null || renderCanvas === void 0 ? void 0 : renderCanvas.toDataURL('image/jpeg') : renderCanvas === null || renderCanvas === void 0 ? void 0 : renderCanvas.toDataURL('image/png');
      return layersPng;
    }
  }, {
    key: "emit",
    value: function emit(name) {
      var _this$eventEmitter;

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      (_this$eventEmitter = this.eventEmitter).emit.apply(_this$eventEmitter, [name].concat(args));
    }
  }, {
    key: "once",
    value: function once(name) {
      var _this$eventEmitter2;

      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      (_this$eventEmitter2 = this.eventEmitter).once.apply(_this$eventEmitter2, [name].concat(args));
    }
  }, {
    key: "destroy",
    value: function destroy() {
      var _this$$mapContainer, _this$$mapContainer$p;

      this.map.destroy();
      (_this$$mapContainer = this.$mapContainer) === null || _this$$mapContainer === void 0 ? void 0 : (_this$$mapContainer$p = _this$$mapContainer.parentNode) === null || _this$$mapContainer$p === void 0 ? void 0 : _this$$mapContainer$p.removeChild(this.$mapContainer);
      delete window.initAMap;
      var $jsapi = document.getElementById(AMAP_SCRIPT_ID);

      if ($jsapi) {
        document.head.removeChild($jsapi);
      }
    }
  }, {
    key: "getMapContainer",
    value: function getMapContainer() {
      return this.$mapContainer;
    }
  }, {
    key: "onCameraChanged",
    value: function onCameraChanged(callback) {
      this.cameraChangedCallback = callback;
    }
  }, {
    key: "handleAfterMapChange",
    value: function handleAfterMapChange() {
      this.emit('mapAfterFrameChange');
    }
  }, {
    key: "getMapStyle",
    value: function getMapStyle(name) {
      return MapTheme[name] ? MapTheme[name] : name;
    }
  }, {
    key: "creatAmapContainer",
    value: function creatAmapContainer(id) {
      var $wrapper = id;

      if (typeof id === 'string') {
        $wrapper = document.getElementById(id);
      }

      var $amapdiv = document.createElement('div');
      $amapdiv.style.cssText += "\n      position: absolute;\n      top: 0;\n      height: 100%;\n      width: 100%;\n    ";
      $amapdiv.id = 'l7_amap_div' + mapdivCount++;
      $wrapper.appendChild($amapdiv);
      return $amapdiv;
    }
  }]);

  return AMapService;
}(), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "configService", [_dec2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "config", [_dec3], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "coordinateSystemService", [_dec4], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "eventEmitter", [_dec5], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
})), _class2)) || _class);
export { AMapService as default };
//# sourceMappingURL=map.js.map