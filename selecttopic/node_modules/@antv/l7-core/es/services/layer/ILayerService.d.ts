import { SyncBailHook, SyncHook, SyncWaterfallHook } from '@antv/async-hook';
import { Container } from 'inversify';
import Clock from '../../utils/clock';
import { ISceneConfig } from '../config/IConfigService';
import { IMapService } from '../map/IMapService';
import { IBlendOptions, IModel, IModelInitializationOptions } from '../renderer/IModel';
import { IMultiPassRenderer, IPass, IPostProcessingPass } from '../renderer/IMultiPassRenderer';
import { IRendererService } from '../renderer/IRendererService';
import { IUniform } from '../renderer/IUniform';
import { ISource, ISourceCFG } from '../source/ISourceService';
import { IAnimateOption, IEncodeFeature, IScale, IScaleOptions, IStyleAttributeService, IStyleAttributeUpdateOptions, StyleAttrField, StyleAttributeField, StyleAttributeOption, Triangulation } from './IStyleAttributeService';
export declare enum BlendType {
    normal = "normal",
    additive = "additive",
    subtractive = "subtractive",
    min = "min",
    max = "max",
    none = "none"
}
export interface IBlendTypes {
    [key: string]: Partial<IBlendOptions>;
}
export interface IDataState {
    dataSourceNeedUpdate: boolean;
    dataMappingNeedUpdate: boolean;
    filterNeedUpdate: boolean;
    featureScaleNeedUpdate: boolean;
    StyleAttrNeedUpdate: boolean;
}
export interface ILayerModelInitializationOptions {
    moduleName: string;
    vertexShader: string;
    fragmentShader: string;
    triangulation: Triangulation;
    segmentNumber?: number;
}
export interface ILayerModel {
    render(): void;
    renderUpdate?(): void;
    getUninforms(): IModelUniform;
    getDefaultStyle(): unknown;
    getAnimateUniforms(): IModelUniform;
    buildModels(): IModel[];
    initModels(): IModel[];
    needUpdate(): boolean;
    clearModels(): void;
    setEarthTime?(time: number): void;
}
export interface IModelUniform {
    [key: string]: IUniform;
}
export interface IPickedFeature {
    x: number;
    y: number;
    lnglat?: {
        lng: number;
        lat: number;
    };
    feature?: unknown;
}
export interface IActiveOption {
    color: string | number[];
    mix?: number;
}
declare type ILngLat = [number, number];
export interface ILegendSegmentItem {
    value: [number, number];
    [key: string]: any;
}
export interface ILegendClassificaItem {
    value: number | string;
    [key: string]: any;
}
export declare type LegendItems = ILegendSegmentItem[] | ILegendClassificaItem[];
export interface ILayer {
    id: string;
    type: string;
    name: string;
    inited: boolean;
    zIndex: number;
    clusterZoom: number;
    plugins: ILayerPlugin[];
    layerModelNeedUpdate: boolean;
    styleNeedUpdate: boolean;
    layerModel: ILayerModel;
    layerChildren: ILayer[];
    sceneContainer: Container | undefined;
    dataState: IDataState;
    pickedFeatureID: number | null;
    hooks: {
        init: SyncBailHook;
        afterInit: SyncBailHook;
        beforeRenderData: SyncWaterfallHook;
        beforeRender: SyncBailHook;
        afterRender: SyncHook;
        beforePickingEncode: SyncHook;
        afterPickingEncode: SyncHook;
        beforeHighlight: SyncHook;
        beforeSelect: SyncHook;
        afterSelect: SyncHook;
        afterHighlight: SyncHook;
        beforeDestroy: SyncHook;
        afterDestroy: SyncHook;
    };
    models: IModel[];
    sourceOption: {
        data: any;
        options?: ISourceCFG;
    };
    multiPassRenderer: IMultiPassRenderer;
    layerType?: string | undefined;
    /**
     * threejs 适配兼容相关的方法
     * @param lnglat
     * @param altitude
     * @param rotation
     * @param scale
     */
    threeRenderService?: any;
    getShaderPickStat: () => boolean;
    needPick(type: string): boolean;
    getLayerConfig(): Partial<ILayerConfig & ISceneConfig>;
    setBottomColor(color: string): void;
    getBottomColor(): string;
    getContainer(): Container;
    setContainer(container: Container, sceneContainer: Container): void;
    setCurrentPickId(id: number | null): void;
    getCurrentPickId(): number | null;
    setCurrentSelectedId(id: number | null): void;
    getCurrentSelectedId(): number | null;
    prepareBuildModel(): void;
    renderModels(isPicking?: boolean): void;
    buildModels(): void;
    rebuildModels(): void;
    buildLayerModel(options: ILayerModelInitializationOptions & Partial<IModelInitializationOptions>): IModel;
    updateStyleAttribute(type: string, field: StyleAttributeField, values?: StyleAttributeOption, updateOptions?: Partial<IStyleAttributeUpdateOptions>): void;
    init(): ILayer;
    scale(field: string | number | IScaleOptions, cfg?: IScale): ILayer;
    getScale(name: string): any;
    size(field: StyleAttrField, value?: StyleAttributeOption): ILayer;
    color(field: StyleAttrField, value?: StyleAttributeOption): ILayer;
    texture(field: StyleAttrField, value?: StyleAttributeOption): ILayer;
    shape(field: StyleAttrField, value?: StyleAttributeOption): ILayer;
    label(field: StyleAttrField, value?: StyleAttributeOption): ILayer;
    animate(option: Partial<IAnimateOption> | boolean): ILayer;
    filter(field: string, value: StyleAttributeOption): ILayer;
    active(option: IActiveOption | boolean): ILayer;
    setActive(id: number | {
        x: number;
        y: number;
    }, option?: IActiveOption): void;
    select(option: IActiveOption | boolean): ILayer;
    setSelect(id: number | {
        x: number;
        y: number;
    }, option?: IActiveOption): void;
    setAutoFit(autoFit: boolean): void;
    style(options: unknown): ILayer;
    hide(): ILayer;
    show(): ILayer;
    getLegendItems(name: string): LegendItems;
    setIndex(index: number): ILayer;
    isVisible(): boolean;
    setMaxZoom(min: number): ILayer;
    setMinZoom(max: number): ILayer;
    getMinZoom(): number;
    getMaxZoom(): number;
    get(name: string): number;
    setBlend(type: keyof typeof BlendType): ILayer;
    setMultiPass(multipass: boolean, passes?: Array<string | [string, {
        [key: string]: unknown;
    }]>): ILayer;
    renderLayers(): void;
    render(): ILayer;
    renderMultiPass(): any;
    clear(): void;
    clearModels(): void;
    destroy(): void;
    source(data: any, option?: ISourceCFG): ILayer;
    setData(data: any, option?: ISourceCFG): ILayer;
    fitBounds(fitBoundsOptions?: unknown): ILayer;
    /**
     * 向当前图层注册插件
     * @param plugin 插件实例
     */
    addPlugin(plugin: ILayerPlugin): ILayer;
    getSource(): ISource;
    setSource(source: ISource): void;
    setEncodedData(encodedData: IEncodeFeature[]): void;
    getEncodedData(): IEncodeFeature[];
    getScaleOptions(): IScaleOptions;
    /**
     * 事件
     */
    on(type: string, handler: (...args: any[]) => void): void;
    off(type: string, handler: (...args: any[]) => void): void;
    emit(type: string, handler: unknown): void;
    once(type: string, handler: (...args: any[]) => void): void;
    isDirty(): boolean;
    /**
     * 直接调用拾取方法，在非鼠标交互场景中使用
     */
    pick(query: {
        x: number;
        y: number;
    }): void;
    boxSelect(box: [number, number, number, number], cb: (...args: any[]) => void): void;
    updateLayerConfig(configToUpdate: Partial<ILayerConfig | unknown>): void;
    setAnimateStartTime(): void;
    getLayerAnimateTime(): number;
    getModelMatrix?(lnglat: ILngLat, altitude: number, rotation: [number, number, number], scale: [number, number, number]): any;
    getTranslateMatrix?(lnglat: ILngLat, altitude?: number): any;
    applyObjectLngLat?(object: any, lnglat: ILngLat, altitude?: number): void;
    setObjectLngLat?(object: any, lnglat: ILngLat, altitude?: number): void;
    getObjectLngLat?(object: any): ILngLat;
    lnglatToCoord?(lnglat: ILngLat): ILngLat;
    adjustMeshToMap?(object: any): void;
    setMeshScale?(object: any, x: number, y: number, z: number): void;
    addAnimateMixer?(mixer: any): void;
    getRenderCamera?(): any;
    /**
     * 地球模式相关的方法
     */
    setEarthTime(time: number): void;
}
/**
 * Layer 插件
 */
export interface ILayerPlugin {
    apply(layer: ILayer, services: {
        rendererService: IRendererService;
        mapService: IMapService;
        styleAttributeService: IStyleAttributeService;
        postProcessingPassFactory: (name: string) => IPostProcessingPass<unknown>;
        normalPassFactory: (name: string) => IPass<unknown>;
    }): void;
}
/**
 * Layer 初始化参数
 */
export interface ILayerConfig {
    colors: string[];
    size: number;
    shape: string;
    shape2d: string[];
    shape3d: string[];
    scales: {
        [key: string]: IScale;
    };
    minZoom: number;
    maxZoom: number;
    visible: boolean;
    zIndex: number;
    pickingBuffer: number;
    enablePropagation: boolean;
    autoFit: boolean;
    fitBoundsOptions?: unknown;
    name: string;
    blend: keyof typeof BlendType;
    depth: boolean;
    pickedFeatureID: number;
    enableMultiPassRenderer: boolean;
    passes: Array<string | [string, {
        [key: string]: unknown;
    }]>;
    layerType?: string | undefined;
    forward: boolean;
    /**
     * 开启拾取
     */
    enablePicking: boolean;
    /**
     * 开启高亮
     */
    enableHighlight: boolean;
    enableSelect: boolean;
    /**
     * 高亮颜色
     */
    highlightColor: string | number[];
    selectColor: string | number[];
    active: boolean;
    activeColor: string | number[];
    activeMix?: number;
    selectMix?: number;
    /**
     * 开启 TAA
     */
    enableTAA: boolean;
    /**
     * 相机抖动程度
     */
    jitterScale: number;
    /**
     * 开启光照
     */
    enableLighting: boolean;
    /**
     * 动画参数
     */
    animateOption: Partial<IAnimateOption>;
    /**
     * 地球模式参数
     */
    globelOtions: any;
    /**
     * layer point text 是否是 iconfont 模式
     */
    iconfont: boolean;
    onHover(pickedFeature: IPickedFeature): void;
    onClick(pickedFeature: IPickedFeature): void;
}
/**
 * 提供 Layer 管理服务
 */
export interface ILayerService {
    clock: Clock;
    alreadyInRendering: boolean;
    sceneService?: any;
    enableShaderPick: () => void;
    disableShaderPick: () => void;
    getShaderPickStat: () => boolean;
    add(layer: ILayer): void;
    initLayers(): void;
    startAnimate(): void;
    stopAnimate(): void;
    getLayers(): ILayer[];
    getRenderList(): ILayer[];
    getLayer(id: string): ILayer | undefined;
    getLayerByName(name: string): ILayer | undefined;
    cleanRemove(layer: ILayer, parentLayer?: ILayer): void;
    remove(layer: ILayer, parentLayer?: ILayer): void;
    removeAllLayers(): void;
    updateLayerRenderList(): void;
    renderLayers(type?: string): void;
    setEnableRender(flag: boolean): void;
    getOESTextureFloat(): boolean;
    destroy(): void;
}
export {};
