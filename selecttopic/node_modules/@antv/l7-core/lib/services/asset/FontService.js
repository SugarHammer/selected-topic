"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.DEFAULT_RADIUS = exports.DEFAULT_FONT_WEIGHT = exports.DEFAULT_FONT_SIZE = exports.DEFAULT_FONT_FAMILY = exports.DEFAULT_CUTOFF = exports.DEFAULT_CHAR_SET = exports.DEFAULT_BUFFER = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _l7Utils = require("@antv/l7-utils");

var _inversify = require("inversify");

var _l7TinySdf = _interopRequireDefault(require("l7-tiny-sdf"));

require("reflect-metadata");

var _font_util = require("../../utils/font_util");

var _dec, _class;

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

var DEFAULT_CHAR_SET = getDefaultCharacterSet();
exports.DEFAULT_CHAR_SET = DEFAULT_CHAR_SET;
var DEFAULT_FONT_FAMILY = 'sans-serif';
exports.DEFAULT_FONT_FAMILY = DEFAULT_FONT_FAMILY;
var DEFAULT_FONT_WEIGHT = 'normal';
exports.DEFAULT_FONT_WEIGHT = DEFAULT_FONT_WEIGHT;
var DEFAULT_FONT_SIZE = 24;
exports.DEFAULT_FONT_SIZE = DEFAULT_FONT_SIZE;
var DEFAULT_BUFFER = 3;
exports.DEFAULT_BUFFER = DEFAULT_BUFFER;
var DEFAULT_CUTOFF = 0.25;
exports.DEFAULT_CUTOFF = DEFAULT_CUTOFF;
var DEFAULT_RADIUS = 8;
exports.DEFAULT_RADIUS = DEFAULT_RADIUS;
var MAX_CANVAS_WIDTH = 1024;
var BASELINE_SCALE = 1.0;
var HEIGHT_SCALE = 1.0;
var CACHE_LIMIT = 3;
var VALID_PROPS = ['fontFamily', 'fontWeight', 'characterSet', 'fontSize', 'sdf', 'buffer', 'cutoff', 'radius'];

function getDefaultCharacterSet() {
  var charSet = [];

  for (var i = 32; i < 128; i++) {
    charSet.push(String.fromCharCode(i));
  }

  return charSet;
}

function setTextStyle(ctx, fontFamily, fontSize, fontWeight) {
  ctx.font = "".concat(fontWeight, " ").concat(fontSize, "px ").concat(fontFamily);
  ctx.fillStyle = 'black';
  ctx.textBaseline = 'middle';
}

function populateAlphaChannel(alphaChannel, imageData) {
  for (var i = 0; i < alphaChannel.length; i++) {
    imageData.data[4 * i + 3] = alphaChannel[i];
  }
}

var FontService = (_dec = (0, _inversify.injectable)(), _dec(_class = function () {
  function FontService() {
    (0, _classCallCheck2.default)(this, FontService);
    (0, _defineProperty2.default)(this, "fontAtlas", void 0);
    (0, _defineProperty2.default)(this, "iconFontMap", void 0);
    (0, _defineProperty2.default)(this, "iconFontGlyphs", {});
    (0, _defineProperty2.default)(this, "fontOptions", void 0);
    (0, _defineProperty2.default)(this, "key", void 0);
    (0, _defineProperty2.default)(this, "cache", new _l7Utils.LRUCache(CACHE_LIMIT));
  }

  (0, _createClass2.default)(FontService, [{
    key: "scale",
    get: function get() {
      return HEIGHT_SCALE;
    }
  }, {
    key: "canvas",
    get: function get() {
      var data = this.cache.get(this.key);
      return data && data.data;
    }
  }, {
    key: "mapping",
    get: function get() {
      var data = this.cache.get(this.key);
      return data && data.mapping;
    }
  }, {
    key: "init",
    value: function init() {
      this.cache.clear();
      this.fontOptions = {
        fontFamily: DEFAULT_FONT_FAMILY,
        fontWeight: DEFAULT_FONT_WEIGHT,
        characterSet: DEFAULT_CHAR_SET,
        fontSize: DEFAULT_FONT_SIZE,
        buffer: DEFAULT_BUFFER,
        sdf: true,
        cutoff: DEFAULT_CUTOFF,
        radius: DEFAULT_RADIUS,
        iconfont: false
      };
      this.key = '';
      this.iconFontMap = new Map();
    }
  }, {
    key: "addIconGlyphs",
    value: function addIconGlyphs(glyphs) {
      var _this = this;

      glyphs.forEach(function (glyph) {
        _this.iconFontGlyphs[glyph.name] = glyph.unicode;
      });
    }
  }, {
    key: "addIconFont",
    value: function addIconFont(name, fontUnicode) {
      this.iconFontMap.set(name, fontUnicode);
    }
  }, {
    key: "getIconFontKey",
    value: function getIconFontKey(name) {
      return this.iconFontMap.get(name) || name;
    }
  }, {
    key: "getGlyph",
    value: function getGlyph(name) {
      if (this.iconFontGlyphs[name]) {
        return String.fromCharCode(parseInt(this.iconFontGlyphs[name], 16));
      }

      return '';
    }
  }, {
    key: "setFontOptions",
    value: function setFontOptions(option) {
      this.fontOptions = _objectSpread(_objectSpread({}, this.fontOptions), option);
      this.key = this.getKey();
      var charSet = this.getNewChars(this.key, this.fontOptions.characterSet);
      var cachedFontAtlas = this.cache.get(this.key);

      if (cachedFontAtlas && charSet.length === 0) {
        return;
      }

      var fontAtlas = this.generateFontAtlas(this.key, charSet, cachedFontAtlas);
      this.fontAtlas = fontAtlas;
      this.cache.set(this.key, fontAtlas);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.cache.clear();
      this.iconFontMap.clear();
    }
  }, {
    key: "generateFontAtlas",
    value: function generateFontAtlas(key, characterSet, cachedFontAtlas) {
      var _this$fontOptions = this.fontOptions,
          fontFamily = _this$fontOptions.fontFamily,
          fontWeight = _this$fontOptions.fontWeight,
          fontSize = _this$fontOptions.fontSize,
          buffer = _this$fontOptions.buffer,
          sdf = _this$fontOptions.sdf,
          radius = _this$fontOptions.radius,
          cutoff = _this$fontOptions.cutoff,
          iconfont = _this$fontOptions.iconfont;
      var canvas = cachedFontAtlas && cachedFontAtlas.data;

      if (!canvas) {
        canvas = _l7Utils.$window.document.createElement('canvas');
        canvas.width = MAX_CANVAS_WIDTH;
      }

      var ctx = canvas.getContext('2d');
      setTextStyle(ctx, fontFamily, fontSize, fontWeight);

      var _buildMapping = (0, _font_util.buildMapping)(_objectSpread({
        getFontWidth: function getFontWidth(char) {
          return ctx.measureText(char).width;
        },
        fontHeight: fontSize * HEIGHT_SCALE,
        buffer: buffer,
        characterSet: characterSet,
        maxCanvasWidth: MAX_CANVAS_WIDTH
      }, cachedFontAtlas && {
        mapping: cachedFontAtlas.mapping,
        xOffset: cachedFontAtlas.xOffset,
        yOffset: cachedFontAtlas.yOffset
      })),
          mapping = _buildMapping.mapping,
          canvasHeight = _buildMapping.canvasHeight,
          xOffset = _buildMapping.xOffset,
          yOffset = _buildMapping.yOffset;

      var copyImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      canvas.height = canvasHeight;
      ctx.putImageData(copyImageData, 0, 0);
      setTextStyle(ctx, fontFamily, fontSize, fontWeight);

      if (sdf) {
        var tinySDF = new _l7TinySdf.default(fontSize, buffer, radius, cutoff, fontFamily, fontWeight);
        var imageData = ctx.getImageData(0, 0, tinySDF.size, tinySDF.size);

        var _iterator = _createForOfIteratorHelper(characterSet),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var char = _step.value;

            if (iconfont) {
              var icon = String.fromCharCode(parseInt(char.replace('&#x', '').replace(';', ''), 16));
              var iconData = tinySDF.draw(icon);
              populateAlphaChannel(iconData, imageData);
            } else {
              populateAlphaChannel(tinySDF.draw(char), imageData);
            }

            ctx.putImageData(imageData, mapping[char].x, mapping[char].y);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      } else {
        var _iterator2 = _createForOfIteratorHelper(characterSet),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var _char = _step2.value;
            ctx.fillText(_char, mapping[_char].x, mapping[_char].y + fontSize * BASELINE_SCALE);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }

      return {
        xOffset: xOffset,
        yOffset: yOffset,
        mapping: mapping,
        data: canvas,
        width: canvas.width,
        height: canvas.height
      };
    }
  }, {
    key: "getKey",
    value: function getKey() {
      return 'key';
      var _this$fontOptions2 = this.fontOptions,
          fontFamily = _this$fontOptions2.fontFamily,
          fontWeight = _this$fontOptions2.fontWeight,
          fontSize = _this$fontOptions2.fontSize,
          buffer = _this$fontOptions2.buffer,
          sdf = _this$fontOptions2.sdf,
          radius = _this$fontOptions2.radius,
          cutoff = _this$fontOptions2.cutoff;

      if (sdf) {
        return "".concat(fontFamily, " ").concat(fontWeight, " ").concat(fontSize, " ").concat(buffer, " ").concat(radius, " ").concat(cutoff, " ");
      }

      return "".concat(fontFamily, " ").concat(fontWeight, " ").concat(fontSize, " ").concat(buffer);
    }
  }, {
    key: "getNewChars",
    value: function getNewChars(key, characterSet) {
      var cachedFontAtlas = this.cache.get(key);

      if (!cachedFontAtlas) {
        return characterSet;
      }

      var newChars = [];
      var cachedMapping = cachedFontAtlas.mapping;
      var cachedCharSet = new Set(Object.keys(cachedMapping));
      var charSet = new Set(characterSet);
      charSet.forEach(function (char) {
        if (!cachedCharSet.has(char)) {
          newChars.push(char);
        }
      });
      return newChars;
    }
  }]);
  return FontService;
}()) || _class);
exports.default = FontService;
//# sourceMappingURL=FontService.js.map