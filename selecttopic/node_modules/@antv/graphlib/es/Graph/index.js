function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

import { edgeArgsToId, isFunction } from '../util';
import { GraphEnum } from '../enum';
import { decrementOrRemoveEntry, edgeArgsToObj, edgeObjToId, incrementOrInitEntry } from '../util';
import { read, write } from './toJSON';
var defaultOption = {
  compound: false,
  multigraph: false,
  directed: true
};

var Graph = /*#__PURE__*/_createClass( // Graph option or basic props

/**
 * @description Label for this graph itself
 * @description.zh-CN 图本身的标签（label）
 * @default undefined
 */

/**
 * @description Number of nodes in the graph
 * @description.zh-CN 节点的数量
 * @default 0
 */

/**
 * @description Number of edges in the graph
 * @description.zh-CN 节点的数量
 * @default 0
 */
function Graph() {
  var _this = this;

  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  _classCallCheck(this, Graph);

  this.directed = true;
  this.multigraph = false;
  this.compound = false;
  this.GRAPH_NODE = GraphEnum.GRAPH_NODE;
  this.label = void 0;
  this.nodeCountNum = 0;
  this.edgeCountNum = 0;

  this.defaultNodeLabelFn = function () {
    return undefined;
  };

  this.defaultEdgeLabelFn = function () {
    return undefined;
  };

  this.parentMap = void 0;
  this.childrenMap = void 0;
  this.nodesLabelMap = new Map();
  this.inEdgesMap = new Map();
  this.outEdgesMap = new Map();
  this.predecessorsMap = new Map();
  this.successorsMap = new Map();
  this.edgesMap = new Map();
  this.edgesLabelsMap = new Map();

  this.isDirected = function () {
    return _this.directed;
  };

  this.isMultigraph = function () {
    return _this.multigraph;
  };

  this.isCompound = function () {
    return _this.compound;
  };

  this.setGraph = function (label) {
    _this.label = label;
    return _this;
  };

  this.graph = function () {
    return _this.label;
  };

  this.setDefaultNodeLabel = function (newDefault) {
    if (isFunction(newDefault)) {
      _this.defaultNodeLabelFn = newDefault;
    } else {
      _this.defaultNodeLabelFn = function () {
        return newDefault;
      };
    }

    return _this;
  };

  this.nodeCount = function () {
    return _this.nodeCountNum;
  };

  this.node = function (n) {
    return _this.nodesLabelMap.get(n);
  };

  this.nodes = function () {
    return Array.from(_this.nodesLabelMap.keys());
  };

  this.sources = function () {
    return _this.nodes().filter(function (n) {
      var _this$inEdgesMap$get;

      return !((_this$inEdgesMap$get = _this.inEdgesMap.get(n)) === null || _this$inEdgesMap$get === void 0 ? void 0 : _this$inEdgesMap$get.size);
    });
  };

  this.sinks = function () {
    return _this.nodes().filter(function (n) {
      var _this$outEdgesMap$get;

      return !((_this$outEdgesMap$get = _this.outEdgesMap.get(n)) === null || _this$outEdgesMap$get === void 0 ? void 0 : _this$outEdgesMap$get.size);
    });
  };

  this.setNode = function (node, value) {
    var nodesLabelMap = _this.nodesLabelMap,
        defaultNodeLabelFn = _this.defaultNodeLabelFn,
        isCompound = _this.isCompound,
        parentMap = _this.parentMap,
        childrenMap = _this.childrenMap,
        inEdgesMap = _this.inEdgesMap,
        outEdgesMap = _this.outEdgesMap,
        predecessorsMap = _this.predecessorsMap,
        successorsMap = _this.successorsMap;

    if (nodesLabelMap.has(node)) {
      if (value !== undefined) {
        nodesLabelMap.set(node, value);
      }

      return _this;
    }

    nodesLabelMap.set(node, value || defaultNodeLabelFn(node));

    if (isCompound()) {
      var _childrenMap$get;

      parentMap === null || parentMap === void 0 ? void 0 : parentMap.set(node, _this.GRAPH_NODE);
      childrenMap === null || childrenMap === void 0 ? void 0 : childrenMap.set(node, new Map());

      if (!(childrenMap === null || childrenMap === void 0 ? void 0 : childrenMap.has(_this.GRAPH_NODE))) {
        childrenMap === null || childrenMap === void 0 ? void 0 : childrenMap.set(_this.GRAPH_NODE, new Map());
      }

      childrenMap === null || childrenMap === void 0 ? void 0 : (_childrenMap$get = childrenMap.get(_this.GRAPH_NODE)) === null || _childrenMap$get === void 0 ? void 0 : _childrenMap$get.set(node, true);
    }

    [inEdgesMap, outEdgesMap, predecessorsMap, successorsMap].forEach(function (map) {
      return map.set(node, new Map());
    });
    _this.nodeCountNum += 1;
    return _this;
  };

  this.setNodes = function (nodes, value) {
    nodes.map(function (node) {
      return _this.setNode(node, value);
    });
    return _this;
  };

  this.hasNode = function (node) {
    return _this.nodesLabelMap.has(node);
  };

  this.checkCompound = function () {
    if (!_this.isCompound()) {
      throw new Error('Cannot construct parent-children relations in a non-compound graph');
    }
  };

  this.parent = function (node) {
    if (_this.isCompound()) {
      var _this$parentMap;

      var parent = (_this$parentMap = _this.parentMap) === null || _this$parentMap === void 0 ? void 0 : _this$parentMap.get(node);

      if (parent !== _this.GRAPH_NODE) {
        return parent;
      }
    }
  };

  this.removeFromParentsChildList = function (node) {
    var targetParent = _this.parentMap.get(node);

    _this.childrenMap.get(targetParent).delete(node);
  };

  this.setParent = function (node, parent) {
    var _this$parentMap2, _this$childrenMap;

    _this.checkCompound();

    var realParent = parent === undefined ? _this.GRAPH_NODE : parent;

    var checkNode = _this.parent(realParent);

    while (checkNode) {
      if (node === checkNode) {
        throw new Error('Setting ' + parent + ' as parent of ' + node + ' would create a cycle');
      }

      checkNode = _this.parent(checkNode);
    }

    if (parent) {
      _this.setNode(parent);
    }

    _this.setNode(node);

    _this.removeFromParentsChildList(node);

    (_this$parentMap2 = _this.parentMap) === null || _this$parentMap2 === void 0 ? void 0 : _this$parentMap2.set(node, realParent);

    var realParentChilren = _this.childrenMap.get(realParent);

    realParentChilren.set(node, true);
    (_this$childrenMap = _this.childrenMap) === null || _this$childrenMap === void 0 ? void 0 : _this$childrenMap.set(realParent, realParentChilren);
    return _this;
  };

  this.children = function (node) {
    var targetNode = node === undefined ? _this.GRAPH_NODE : node;

    if (_this.isCompound()) {
      var _this$childrenMap2;

      var target = (_this$childrenMap2 = _this.childrenMap) === null || _this$childrenMap2 === void 0 ? void 0 : _this$childrenMap2.get(targetNode);

      if (target) {
        return Array.from(target.keys());
      }

      return undefined;
    }

    if (targetNode === _this.GRAPH_NODE) {
      return _this.nodes();
    }

    if (node && _this.hasNode(node)) {
      return [];
    }
  };

  this.predecessors = function (node) {
    var preds = _this.predecessorsMap.get(node);

    return preds ? Array.from(preds.keys()) : undefined;
  };

  this.successors = function (node) {
    var succs = _this.successorsMap.get(node);

    return succs ? Array.from(succs.keys()) : undefined;
  };

  this.neighbors = function (node) {
    var _this$predecessors;

    if (!_this.hasNode(node)) {
      return undefined;
    }

    return Array.from(new Set((_this$predecessors = _this.predecessors(node)) === null || _this$predecessors === void 0 ? void 0 : _this$predecessors.concat(_this.successors(node))));
  };

  this.isLeaf = function (node) {
    var _this$neighbors;

    if (_this.isDirected()) {
      var _this$successors;

      return !((_this$successors = _this.successors(node)) === null || _this$successors === void 0 ? void 0 : _this$successors.length);
    }

    return !((_this$neighbors = _this.neighbors(node)) === null || _this$neighbors === void 0 ? void 0 : _this$neighbors.length);
  };

  this.filterNodes = function (filter) {
    var directed = _this.directed,
        multigraph = _this.multigraph,
        compound = _this.compound;
    var copyGraph = new Graph({
      directed: directed,
      multigraph: multigraph,
      compound: compound
    });
    copyGraph.setGraph(_this.graph());

    _this.nodes().forEach(function (n) {
      if (filter(n)) {
        copyGraph.setNode(n, _this.node(n));
      }
    });

    _this.edges().forEach(function (edgeObj) {
      if (copyGraph.hasNode(edgeObj.v) && copyGraph.hasNode(edgeObj.w)) {
        copyGraph.setEdgeObj(edgeObj, _this.edge(edgeObj));
      }
    });

    if (compound) {
      var findParent = function findParent(node) {
        var parent = _this.parent(node);

        while (parent !== undefined && !copyGraph.hasNode(parent)) {
          parent = _this.parent(parent);
        }

        return parent;
      };

      copyGraph.nodes().forEach(function (node) {
        copyGraph.setParent(node, findParent(node));
      });
    }

    return copyGraph;
  };

  this.removeNode = function (node) {
    if (_this.hasNode(node)) {
      var cleanEdge = function cleanEdge(edgeObj) {
        _this.removeEdge(edgeObj.v, edgeObj.w, edgeObj.name);
      };

      var inEdgesMap = _this.inEdgesMap,
          outEdgesMap = _this.outEdgesMap,
          predecessorsMap = _this.predecessorsMap,
          successorsMap = _this.successorsMap,
          nodesLabelMap = _this.nodesLabelMap;

      if (_this.isCompound()) {
        var _this$parentMap3, _this$children, _this$childrenMap3;

        _this.removeFromParentsChildList(node);

        (_this$parentMap3 = _this.parentMap) === null || _this$parentMap3 === void 0 ? void 0 : _this$parentMap3.delete(node);
        (_this$children = _this.children(node)) === null || _this$children === void 0 ? void 0 : _this$children.forEach(function (n) {
          return _this.setParent(n);
        });
        (_this$childrenMap3 = _this.childrenMap) === null || _this$childrenMap3 === void 0 ? void 0 : _this$childrenMap3.delete(node);
      }

      var inE = inEdgesMap.get(node);
      var outE = outEdgesMap.get(node);
      Array.from(inE.values()).forEach(function (edge) {
        return cleanEdge(edge);
      });
      Array.from(outE.values()).forEach(function (edge) {
        return cleanEdge(edge);
      });
      nodesLabelMap.delete(node);
      inEdgesMap.delete(node);
      outEdgesMap.delete(node);
      predecessorsMap.delete(node);
      successorsMap.delete(node);
      _this.nodeCountNum -= 1;
    }

    return _this;
  };

  this.setDefaultEdgeLabel = function (newDefault) {
    if (isFunction(newDefault)) {
      _this.defaultEdgeLabelFn = newDefault;
    } else {
      _this.defaultEdgeLabelFn = function () {
        return newDefault;
      };
    }

    return _this;
  };

  this.edgeCount = function () {
    return _this.edgeCountNum;
  };

  this.setEdge = function (v_, w_, value, name) {
    var _this$inEdgesMap$get2, _this$outEdgesMap$get2;

    var edgeObj = edgeArgsToObj(_this.isDirected(), v_, w_, name);
    var edgeId = edgeObjToId(_this.isDirected(), edgeObj);
    var v = edgeObj.v,
        w = edgeObj.w;

    if (_this.edgesLabelsMap.has(edgeId)) {
      _this.edgesLabelsMap.set(edgeId, value);

      return _this;
    }

    if (name !== undefined && !_this.isMultigraph()) {
      throw new Error('Cannot set a named edge when isMultigraph = false');
    }

    _this.setNode(v);

    _this.setNode(w);

    _this.edgesLabelsMap.set(edgeId, value || _this.defaultEdgeLabelFn(v, w, name));

    Object.freeze(edgeObj);

    _this.edgesMap.set(edgeId, edgeObj);

    var preds = _this.predecessorsMap.get(w);

    var succs = _this.successorsMap.get(v);

    incrementOrInitEntry(preds, v);
    incrementOrInitEntry(succs, w);
    (_this$inEdgesMap$get2 = _this.inEdgesMap.get(w)) === null || _this$inEdgesMap$get2 === void 0 ? void 0 : _this$inEdgesMap$get2.set(edgeId, edgeObj);
    (_this$outEdgesMap$get2 = _this.outEdgesMap.get(v)) === null || _this$outEdgesMap$get2 === void 0 ? void 0 : _this$outEdgesMap$get2.set(edgeId, edgeObj);
    _this.edgeCountNum += 1;
    return _this;
  };

  this.setEdgeObj = function (edgeObj, value) {
    return _this.setEdge(edgeObj.v, edgeObj.w, value, edgeObj.name);
  };

  this.setPath = function (edges, value) {
    edges.reduce(function (v, w) {
      _this.setEdge(v, w, value);

      return w;
    });
    return _this;
  };

  this.edgeFromArgs = function (v, w, name) {
    return _this.edge({
      v: v,
      w: w,
      name: name
    });
  };

  this.edge = function (edgeObj) {
    return _this.edgesLabelsMap.get(edgeObjToId(_this.isDirected(), edgeObj));
  };

  this.hasEdge = function (v, w, name) {
    return _this.edgesLabelsMap.has(edgeObjToId(_this.isDirected(), {
      v: v,
      w: w,
      name: name
    }));
  };

  this.removeEdge = function (v_, w_, name) {
    var edgeId = edgeArgsToId(_this.isDirected(), v_, w_, name);

    var edgeObj = _this.edgesMap.get(edgeId);

    if (edgeObj) {
      var _edgeArgsToObj = edgeArgsToObj(_this.isDirected(), v_, w_, name),
          v = _edgeArgsToObj.v,
          w = _edgeArgsToObj.w;

      _this.edgesLabelsMap.delete(edgeId);

      _this.edgesMap.delete(edgeId);

      var preds = _this.predecessorsMap.get(w);

      var succs = _this.successorsMap.get(v);

      decrementOrRemoveEntry(preds, v);
      decrementOrRemoveEntry(succs, w);

      _this.inEdgesMap.get(w).delete(edgeId);

      _this.outEdgesMap.get(v).delete(edgeId);

      _this.edgeCountNum -= 1;
    }

    return _this;
  };

  this.removeEdgeObj = function (_ref) {
    var v = _ref.v,
        w = _ref.w,
        name = _ref.name;
    return _this.removeEdge(v, w, name);
  };

  this.edges = function () {
    return Array.from(_this.edgesMap.values());
  };

  this.inEdges = function (v, u) {
    var inV = _this.inEdgesMap.get(v);

    if (inV) {
      return Array.from(inV.values()).filter(function (e) {
        return !u || e.v === u;
      });
    }

    return undefined;
  };

  this.outEdges = function (w, u) {
    var outW = _this.outEdgesMap.get(w);

    if (outW) {
      return Array.from(outW.values()).filter(function (e) {
        return !u || e.w === u;
      });
    }

    return undefined;
  };

  this.nodeEdges = function (v, w) {
    var _this$inEdges;

    if (!_this.hasNode(v)) {
      return undefined;
    }

    return (_this$inEdges = _this.inEdges(v, w)) === null || _this$inEdges === void 0 ? void 0 : _this$inEdges.concat(_this.outEdges(v, w));
  };

  this.toJSON = function () {
    return write(_this);
  };

  var resultOptions = _objectSpread(_objectSpread({}, defaultOption), options);

  this.compound = resultOptions.compound;
  this.directed = resultOptions.directed;
  this.multigraph = resultOptions.multigraph;

  if (this.compound) {
    this.parentMap = new Map();
    this.childrenMap = new Map();
  }
} // Map for graph
);

Graph.fromJSON = read;
export { Graph as default };